#include "hardware.inc"
Chd|====================================================================
Chd|  SPMD_MIN_MAX                  priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        SCANOR                        src/anim/scanor.F             
Chd|        SPHPREP                       src/sph/sphprep.F             
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_MIN_MAX(X1,Y1,Z1,X2,Y2,Z2)
C spmd_min_max calcule les minimum des reels X1, Y1, Z1 et les
C maximum des reels X2, Y2, Z2 sur p0
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
C   REAL*4 ou REAL*8
      my_real
     .  X1, Y1, Z1, X2, Y2, Z2
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER INFO,K,I,ATID,ATAG,ALEN
C  REAL*4 ou REAL*8
      my_real
     .  TMP(6)

      INTEGER STATUS(MPI_STATUS_SIZE),IERROR
C  REAL*4 ou REAL*8
      my_real
     .  TMP1(3),TMPO(3)
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      TMP1(1) = X1
      TMP1(2) = Y1
      TMP1(3) = Z1
      call MPI_ALLREDUCE(TMP1,TMPO,3,REAL,
     .                   MPI_MIN,
     .                   MPI_COMM_WORLD,ierror)
      X1 = TMPO(1)
      Y1 = TMPO(2)
      Z1 = TMPO(3)
C
      TMP1(1)=X2
      TMP1(2)=Y2
      TMP1(3)=Z2
      call MPI_ALLREDUCE(TMP1,TMPO,3,REAL,
     .                   MPI_MAX,
     .                   MPI_COMM_WORLD,ierror)
      X2 = TMPO(1)
      Y2 = TMPO(2)
      Z2 = TMPO(3)

C
#endif
      RETURN
      END
C
Chd|====================================================================
Chd|  SPMD_EXCH_N                   priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|        I20MAINF                      src/int20/i20mainf.F          
Chd|        I7MAINF                       src/int7/i7mainf.F            
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_EXCH_N(XNORM,IAD_ELEM,FR_ELEM,LENR)
C realise la sommation des normales aux points frontiere
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER IAD_ELEM(2,*),FR_ELEM(*), SIZE, LENR
      my_real XNORM(3,*)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGTYP,I,NOD,LOC_PROC,IERROR,
     .        SIZ,J,K,L,NB_NOD,
     .        STATUS(MPI_STATUS_SIZE),
     .        IAD_SEND(NSPMD+1),IAD_RECV(NSPMD+1),
     .        REQ_R(NSPMD),REQ_S(NSPMD),MSGOFF

      my_real, DIMENSION(:),ALLOCATABLE :: SBUF,RBUF

      DATA MSGOFF/7000/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(SBUF(LENR*3))
      ALLOCATE(RBUF(LENR*3))
C-----------------------------------------------
      LOC_PROC = ISPMD+1
      L = 1
      IAD_RECV(1)=1

Cow Mise en place des buffers de reception
      DO I=1,NSPMD
         SIZ = 3*(IAD_ELEM(1,I+1)-IAD_ELEM(1,I))
         IF(SIZ.NE.0) THEN
           MSGTYP = MSGOFF
           CALL MPI_IRECV(
     S      RBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_R(I),IERROR)
           L = L+SIZ
         END IF
         IAD_RECV(I+1) = L
      END DO

Cow Remplissage des buffers d'envoi et envoi des donnees
      L=1
      IAD_SEND(1)=1
      DO I=1,NSPMD
         DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1
            NOD = FR_ELEM(J)
            SBUF(L  ) = XNORM(1,NOD)
            SBUF(L+1) = XNORM(2,NOD)
            SBUF(L+2) = XNORM(3,NOD)
            L = L+3
         END DO
        IAD_SEND(I+1) = L
      END DO

      DO I=1,NSPMD

       IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN

          MSGTYP = MSGOFF
          SIZ = IAD_SEND(I+1)-IAD_SEND(I)
          L = IAD_SEND(I)
          CALL MPI_ISEND(
     S      SBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_S(I),IERROR)
       ENDIF                
      END DO

Cow Reception et traitement
      DO I = 1, NSPMD
C
        NB_NOD = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
        IF(NB_NOD.GT.0)THEN
          CALL MPI_WAIT(REQ_R(I),STATUS,IERROR)
          L = IAD_RECV(I)

          DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1

             NOD = FR_ELEM(J)
             XNORM(1,NOD) = XNORM(1,NOD) + RBUF(L)
             XNORM(2,NOD) = XNORM(2,NOD) + RBUF(L+1)
             XNORM(3,NOD) = XNORM(3,NOD) + RBUF(L+2)
             L = L+3
          ENDDO
        ENDIF
      ENDDO

      DO I = 1, NSPMD
        IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN
          CALL MPI_WAIT(REQ_S(I),STATUS,IERROR)
        ENDIF
      ENDDO

      DEALLOCATE(SBUF)
      DEALLOCATE(RBUF)

#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_EXCH_ADM                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        SORTIE_MAIN                   src/sortie/sortie_main.F      
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_EXCH_ADM(ADM,IAD_ELEM,FR_ELEM,LENR,WEIGHT_MD)
C realise la sommation des ajouts de masses au noeuds frontieres
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER  IAD_ELEM(2,*),FR_ELEM(*), SIZE, LENR,WEIGHT_MD(*)
      my_real ADM(*)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGTYP,I,NOD,LOC_PROC,IERROR,
     .        SIZ,J,K,L,NB_NOD,
     .        STATUS(MPI_STATUS_SIZE),
     .        IAD_SEND(NSPMD+1),IAD_RECV(NSPMD+1),
     .        REQ_R(NSPMD),REQ_S(NSPMD),MSGOFF

      my_real, DIMENSION(:), ALLOCATABLE :: SBUF,RBUF
      DATA MSGOFF/7001/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(SBUF(LENR+1))
      ALLOCATE(RBUF(LENR+1))
C-----------------------------------------------
      LOC_PROC = ISPMD+1
      L = 1
      IAD_RECV(1)=1

Cow Mise en place des buffers de reception
      DO I=1,NSPMD
         SIZ = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
         IF(SIZ.NE.0) THEN
           MSGTYP = MSGOFF
           CALL MPI_IRECV(
     S      RBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_R(I),IERROR)
           L = L+SIZ
         END IF
         IAD_RECV(I+1) = L
      END DO

Cow Remplissage des buffers d'envoi et envoi des donnees
C
      L=1
      IAD_SEND(1)=1
      DO I=1,NSPMD
         DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1
            NOD = FR_ELEM(J)
            SBUF(L) = ADM(NOD)
            L = L+1
         END DO
        IAD_SEND(I+1) = L
      END DO

      DO I=1,NSPMD

       IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN

          
          MSGTYP = MSGOFF
          SIZ = IAD_SEND(I+1)-IAD_SEND(I)
          L = IAD_SEND(I)

          CALL MPI_ISEND(
     S      SBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_S(I),IERROR)
       ENDIF                
      END DO
Cow Reception et traitement
      DO I = 1, NSPMD
C
        NB_NOD = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
        IF(NB_NOD.GT.0)THEN
          CALL MPI_WAIT(REQ_R(I),STATUS,IERROR)
          L = IAD_RECV(I)

          DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1

             NOD = FR_ELEM(J)
             ADM(NOD) = ADM(NOD) + RBUF(L)
             L = L+1
          ENDDO
        ENDIF
      ENDDO

      DO I = 1, NSPMD
        IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN
          CALL MPI_WAIT(REQ_S(I),STATUS,IERROR)
        ENDIF
      ENDDO
C
C Mise a 0 de adm sur noeud non maitre
C
      DO I = 1, NUMNOD
        IF(WEIGHT_MD(I).EQ.0) ADM(I) = ZERO
      ENDDO
C
      DEALLOCATE(SBUF)
      DEALLOCATE(RBUF)
C-----------------------------------------------
#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_R4GET_PARTN              priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        ANIMCALE                      src/anim/genani.F             
Chd|        DFUNC0                        src/anim/dfunc0.F             
Chd|        DFUNCC                        src/anim/dfuncc.F             
Chd|        DFUNCC_CRK                    src/anim/dfuncc_crk.F         
Chd|        DFUNCC_PLY                    src/anim/dfuncc_ply.F         
Chd|        DFUNCF                        src/anim/dfuncf.F             
Chd|        DFUNCS                        src/anim/dfunc6.F             
Chd|        GENANI                        src/anim/genani.F             
Chd|        TENSOR0                       src/anim/tensor0.F            
Chd|        TENSORC                       src/anim/tensorc.F            
Chd|        TENSORC_CRK                   src/anim/tensorc_crk.F        
Chd|        TENSORC_PLY                   src/anim/tensorc_ply.F        
Chd|        TENSORS                       src/anim/tensor6.F            
Chd|        TORSEUR                       src/anim/torseur.F            
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_R4GET_PARTN(SIZE,NBF_L,NBPART,IADG,WAL,BUF)
C gather sur p0 du tableau wa en fonction des parts (IADG)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif

C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NBF_L, NBPART, SIZE, IFLAG, IADG(NSPMD,*),BUF
      REAL WAL(*)
      REAL, DIMENSION(:), ALLOCATABLE :: WAR
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGTYP,INFO,IDEB,K,N,NB_TMP,LEN,IADP(NSPMD)
      REAL AUX
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR
      DATA MSGOFF/7002/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(WAR(BUF+1))

      IF (ISPMD.NE.0) THEN
        MSGTYP=MSGOFF
        CALL MPI_SEND(WAL,NBF_L,MPI_REAL4,IT_SPMD(1),MSGTYP,
     .                MPI_COMM_WORLD,ierror)

      ELSE
Cow
        DO K=1,NBF_L
          WAR(K) = WAL(K)
        END DO

        IDEB = NBF_L + 1
        IADP(1) = 1
C
        DO K=2,NSPMD
          IADP(K) = IDEB
          MSGTYP=MSGOFF

          CALL MPI_PROBE(IT_SPMD(K),MSGTYP,
     .                   MPI_COMM_WORLD,STATUS,ierror)
          CALL MPI_GET_COUNT(STATUS,MPI_REAL4,NB_TMP,ierror)
          CALL MPI_RECV(WAR(IDEB),NB_TMP,MPI_REAL4,IT_SPMD(K),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

          IDEB = IDEB + NB_TMP
        END DO
        DO N = 1, NBPART
          DO K = 1, NSPMD
            IF (N.GT.1) THEN
              LEN = (IADG(K,N) - IADG(K,N-1))*SIZE
            ELSE
              LEN = IADG(K,N)*SIZE
            ENDIF
            IF(LEN>0)CALL WRITE_R_C(WAR(IADP(K)),LEN)
            IADP(K) = IADP(K) + LEN
          ENDDO
        ENDDO
      ENDIF
C
      DEALLOCATE(WAR)
#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_VGATH                    priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        VELVEC                        src/anim/velvec.F             
Chd|        VELVEC3                       src/anim/velvec.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
       SUBROUTINE SPMD_VGATH(X,NODGLOB,WEIGHT,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real
     .   X(3,*)
       INTEGER WEIGHT(*),NODGLOB(*),NUM,SRECBUF
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      DATA MSGOFF/7003/
      DATA MSGOFF2/7004/
      REAL, DIMENSION(:,:) , ALLOCATABLE :: BUFSR
      INTEGER, DIMENSION(:), ALLOCATABLE :: IBUF
Cow Tableau utilise par proc 0
       REAL, DIMENSION(:,:), ALLOCATABLE :: XGLOB
C===================================================================
       ALLOCATE(BUFSR(3,NUMNODM), IBUF(NUMNODM))
       ALLOCATE(XGLOB(3,NUM))
        
       IF (ISPMD.NE.0) THEN

         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             IBUF(SIZ) = NODGLOB(I)
             BUFSR(1,SIZ) = X(1,I)
             BUFSR(2,SIZ) = X(2,I) 
             BUFSR(3,SIZ) = X(3,I) 
           END IF
         END DO

Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

         MSGTYP = MSGOFF2 
         CALL MPI_SEND(IBUF,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF
         CALL MPI_SEND(BUFSR,3*SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              NG = NODGLOB(I)
              XGLOB(1,NG) = X(1,I)
              XGLOB(2,NG) = X(2,I)
              XGLOB(3,NG) = X(3,I)
            ENDIF
          ENDDO

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF2

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Cow Reception du buffer flottant des adresses NODGLOB

            MSGTYP = MSGOFF
            CALL MPI_RECV(BUFSR,3*SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            NREC = SIZ
 
            DO K = 1, NREC
              NG = IBUF(K)
              XGLOB(1,NG) = BUFSR(1,K)
              XGLOB(2,NG) = BUFSR(2,K)
              XGLOB(3,NG) = BUFSR(3,K)
            ENDDO
          ENDDO
          CALL WRITE_R_C(XGLOB,3*NUMNODG)

       ENDIF
       DEALLOCATE (BUFSR,IBUF,XGLOB)
       
#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_VGATH2                   priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
       SUBROUTINE SPMD_VGATH2(X,XG,NODGLOB,WEIGHT,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real
     .   X(3,*), XG(3,*)
       INTEGER WEIGHT(*),NODGLOB(*),SRECBUF,NUM
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      DATA MSGOFF/7005/
      DATA MSGOFF2/7006/
      REAL, DIMENSION(:,:) , ALLOCATABLE :: BUFSR
      INTEGER, DIMENSION(:), ALLOCATABLE :: IBUF
Cow Tableau utilise par proc 0
       REAL, DIMENSION(:,:), ALLOCATABLE :: XGLOB         
C===================================================================
       ALLOCATE(BUFSR(3,NUMNODM), IBUF(NUMNODM))
       ALLOCATE(XGLOB(3,NUM))

       IF (ISPMD.NE.0) THEN

         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             IBUF(SIZ) = NODGLOB(I)
             BUFSR(1,SIZ) = X(1,I)
             BUFSR(2,SIZ) = X(2,I) 
             BUFSR(3,SIZ) = X(3,I) 
           END IF
         END DO

Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

         MSGTYP = MSGOFF2 
         CALL MPI_SEND(IBUF,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF 
         CALL MPI_SEND(BUFSR,3*SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              NG = NODGLOB(I)
              XGLOB(1,NG) = X(1,I)
              XGLOB(2,NG) = X(2,I)
              XGLOB(3,NG) = X(3,I)
            ENDIF
          ENDDO

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF2 

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Cow Reception du buffer flottant des adresses NODGLOB

            MSGTYP = MSGOFF
            CALL MPI_RECV(BUFSR,3*SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            NREC = SIZ
 
            DO K = 1, NREC
              NG = IBUF(K)
              XGLOB(1,NG) = BUFSR(1,K)
              XGLOB(2,NG) = BUFSR(2,K)
              XGLOB(3,NG) = BUFSR(3,K)
            ENDDO
          ENDDO
          DO I=1,NUMNODG
             XGLOB(1,I) = XGLOB(1,I) + XG(1,I)
             XGLOB(2,I) = XGLOB(2,I) + XG(2,I)
             XGLOB(3,I) = XGLOB(3,I) + XG(3,I)
          ENDDO
          CALL WRITE_R_C(XGLOB,3*NUMNODG)

       ENDIF
       DEALLOCATE (BUFSR,IBUF,XGLOB)
#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_VGATH_ERR                priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        SORTIE_ERROR                  src/sortie/sortie_error.F     
Chd|-- calls ---------------
Chd|        SPMD_OUTPITAB                 priv/spe/spmd_outp.F          
Chd|====================================================================
       SUBROUTINE SPMD_VGATH_ERR(X,MS,MSINI,NODGLOB,WEIGHT,NUM,IFLAG,
     .                           ITAB,LENG)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "scr18_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
#include      "units_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real
     .   X(3,*),MS(*),MSINI(*)
       INTEGER WEIGHT(*),NODGLOB(*),NUM,IFLAG,ITAB(*),LENG
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      REAL, DIMENSION(:) , ALLOCATABLE :: MAXV0, MAXV1, MAXV2 

      my_real
     .       , DIMENSION(:), ALLOCATABLE :: V, MAXV, MAXV_1, MAXV_2, MAXV_RES0,
     .                                      MAXV_RES1, MAXV_RES2

      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF,FLAG,ITABG(LENG)
      INTEGER SIZ,MSGTYP,I,J,K,NG,NREC,MSGOFF2,
     .        L,ISMASSCHANGE,MSGOFF3,MSGOFF4
      INTEGER, DIMENSION(:) , ALLOCATABLE :: IDNOD0, IDNOD, IDNOD_RES

      DATA MSGOFF/7007/
      DATA MSGOFF2/7008/
      DATA MSGOFF3/7009/
      DATA MSGOFF4/7010/
C===================================================================
      IF (NSPMD > 1)
     .    CALL SPMD_OUTPITAB(ITAB,WEIGHT,NODGLOB,ITABG)
c
       ALLOCATE(MAXV0(NUM),MAXV1(NUM),MAXV2(NUM))

       ALLOCATE(V(NUMNOD),MAXV(NUM),MAXV_1(NUM),MAXV_2(NUM),MAXV_RES0(NUM),
     .          MAXV_RES1(NUM),MAXV_RES2(NUM))

       ALLOCATE(IDNOD0(NUM),IDNOD(NUM),IDNOD_RES(NUM))

       IDNOD(1:NUM) = 0
       IDNOD0(1:NUM) = 0
       MAXV(1:NUM) = ZERO
       MAXV_1(1:NUM) = ZERO
       MAXV_2(1:NUM) = ZERO
       MAXV0(1:NUM) = ZERO
       SIZ = NUM
       IF(IFLAG==1)THEN
         DO I=1,NUMNOD
           V(I)=SQRT(X(1,I)**2+X(2,I)**2+X(3,I)**2)
         ENDDO
       ELSEIF(IFLAG==2)THEN
         DO I=1,NUMNOD
           V(I)=UNDEMI*MS(I)*(X(1,I)**2+X(2,I)**2+X(3,I)**2)
         ENDDO
       ELSEIF(IFLAG==3)THEN
         DO I=1,NUMNOD
           V(I)=MS(I)
         ENDDO
       ELSEIF(IFLAG==4)THEN
         DO I=1,NUMNOD
           V(I)=(MS(I)-MSINI(I))/MAX(EM20,MSINI(I))
         ENDDO
       ENDIF
       IF (ISPMD.NE.0) THEN

         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             FLAG = 0
             DO J=1,NUM
               IF(V(I) .GT. MAXV0(J) .AND. FLAG == 0) THEN
                 DO K=1,NUM-J
                   IDNOD0(NUM-K+1) = IDNOD0(NUM-K)
                   MAXV0(NUM-K+1) = MAXV0(NUM-K) 
                   MAXV1(NUM-K+1) = MAXV1(NUM-K) 
                   MAXV2(NUM-K+1) = MAXV2(NUM-K) 
                 ENDDO
                 IDNOD0(J) = NODGLOB(I)
                 MAXV0(J) = V(I)
                 MAXV1(J) = MS(I)
                 MAXV2(J) = MSINI(I)
                 FLAG = 1
               ENDIF
             ENDDO
           END IF
         END DO

Csv a cause de la version simple precision, on ne peux pas metre l'entier
Csv dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Csv de noeuds au max

         MSGTYP = MSGOFF
         CALL MPI_SEND(IDNOD0,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF2
         CALL MPI_SEND(MAXV0,SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF3
         CALL MPI_SEND(MAXV1,SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF4 
         CALL MPI_SEND(MAXV2,SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE ! ISPMD == 0
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              FLAG = 0
              DO J=1,NUM
                IF(V(I) .GT. MAXV(J) .AND. FLAG == 0) THEN
                  DO K=1,NUM-J
                    IDNOD(NUM-K+1) = IDNOD(NUM-K)
                    MAXV(NUM-K+1) = MAXV(NUM-K) 
                    MAXV_1(NUM-K+1) = MAXV_1(NUM-K)
                    MAXV_2(NUM-K+1) = MAXV_2(NUM-K)
                  ENDDO
                  IDNOD(J) = NODGLOB(I)
                  MAXV(J) = V(I)
                  MAXV_1(J) = MS(I)
                  MAXV_2(J) = MSINI(I)
                  FLAG = 1
                ENDIF
              ENDDO

            ENDIF
          ENDDO

          DO I=2,NSPMD

Csv Reception 
            MSGTYP = MSGOFF

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IDNOD0,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Csv Reception

            MSGTYP = MSGOFF2 
            CALL MPI_RECV(MAXV0,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

            MSGTYP = MSGOFF3
            CALL MPI_RECV(MAXV1,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

            MSGTYP = MSGOFF4 
            CALL MPI_RECV(MAXV2,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)


            J = 1
            K = 1
            L = 1
            DO WHILE( J <= SIZ .AND. K <= SIZ .AND. L <= SIZ)
                IF(MAXV(J) .GT. MAXV0(K))THEN
                  MAXV_RES0(L) = MAXV(J)
                  IDNOD_RES(L) = IDNOD(J)
                  MAXV_RES1(L) = MAXV_1(J)
                  MAXV_RES2(L) = MAXV_2(J)
                  J = J + 1
                  L = L + 1
                ELSEIF(MAXV0(K) .GT. MAXV(J))THEN
                  MAXV_RES0(L) = MAXV0(K)
                  IDNOD_RES(L) = IDNOD0(K)
                  MAXV_RES1(L) = MAXV1(K)
                  MAXV_RES2(L) = MAXV2(K)
                  K = K + 1
                  L = L + 1
                ELSE
                  MAXV_RES0(L) = MAXV0(K)
                  IDNOD_RES(L) = IDNOD0(K)
                  MAXV_RES1(L) = MAXV1(K)
                  MAXV_RES2(L) = MAXV2(K)
                  J = J + 1
                  K = K + 1
                  L = L + 1
                ENDIF
            ENDDO
            DO J=1,SIZ
              MAXV(J) =  MAXV_RES0(J)
              IDNOD(J) = IDNOD_RES(J)
              MAXV_1(J) =  MAXV_RES1(J)
              MAXV_2(J) =  MAXV_RES2(J)
            ENDDO

          ENDDO
          IF(IFLAG == 1)THEN
            WRITE(IOUT,2000)
            WRITE(IOUT,1000)
            WRITE(IOUT,2000)
            WRITE(IOUT,1001)
            DO I=1,NUM
              IF(MAXV_RES0(I) .NE. ZERO)THEN
                WRITE(IOUT,1100) ITABG(IDNOD_RES(I)),MAXV_RES0(I),
     .               UNDEMI*(MAXV_RES1(I))*MAXV_RES0(I)**2,
     .               MAXV_RES1(I),MAXV_RES2(I),
     .               (MAXV_RES1(I)-MAXV_RES2(I))/MAX(EM20,MAXV_RES2(I))
              ENDIF
            ENDDO
          ELSEIF(IFLAG == 2)THEN
            WRITE(IOUT,2000)
            WRITE(IOUT,1200)
            WRITE(IOUT,2000)
            WRITE(IOUT,1201)
            DO I=1,NUM
              WRITE(IOUT,1300) ITABG(IDNOD_RES(I)),MAXV_RES0(I)
            ENDDO
          ELSEIF(IFLAG == 3)THEN
            WRITE(IOUT,2000)
            WRITE(IOUT,1400)
            WRITE(IOUT,2000)
            WRITE(IOUT,1401)
            DO I=1,NUM
              WRITE(IOUT,1500) ITABG(IDNOD_RES(I)),MAXV_RES0(I)
            ENDDO
          ELSEIF(IFLAG == 4 .AND. (IDTMIN(11) == 3 .OR.IDTMIN(11)==8))THEN
            ISMASSCHANGE = 0
            DO I=1,NUM
              IF(MAXV_RES0(I) .NE.ZERO) ISMASSCHANGE = 1
            ENDDO
            IF(ISMASSCHANGE .NE. 0)THEN
              WRITE(IOUT,2000)
              WRITE(IOUT,1600)
              WRITE(IOUT,2000)
              WRITE(IOUT,1601)
              DO I=1,NUM
               IF(MAXV_RES0(I) .NE. ZERO)
     .         WRITE(IOUT,1700) ITABG(IDNOD_RES(I)),MAXV_RES1(I),
     .                          MAXV_RES2(I),MAXV_RES0(I)
              ENDDO
            ENDIF
          ENDIF 
       ENDIF
C
 1000 FORMAT('***  NODES WITH HIGHEST VELOCITY')
 1001 FORMAT('      NODE   VELOCITY     K-ENER       MASS      MASS0
     .   DM/MASS0')
 1100 FORMAT(I10,5G11.4)
c
 1200 FORMAT('***  NODES WITH HIGHEST KINEMATIC ENERGY')
 1201 FORMAT('  NODE   K-ENER    MASS  MASS0   MASS/MASS0')
 1300 FORMAT(I10,G11.4)
c
 1400 FORMAT('***  NODES WITH HIGHEST MASS')
 1401 FORMAT('  NODE     MASS  MASS0   MASS/MASS0')
 1500 FORMAT(I10,G11.4)
c
 1600 FORMAT('***  NODES WITH HIGHEST MASS CHANGE')
 1601 FORMAT('      NODE       MASS      MASS0   DM/MASS0')
 1700 FORMAT(I10,3G11.4)
c
 2000 FORMAT('      ')
 2100 FORMAT('                          ** STATISTICS   **')
c
       DEALLOCATE(MAXV0,MAXV1,MAXV2)
       DEALLOCATE(V,MAXV,MAXV_RES0,MAXV_RES1,MAXV_RES2)
       DEALLOCATE(IDNOD0,IDNOD,IDNOD_RES)
      
#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_RGATH                    priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
       SUBROUTINE SPMD_RGATH(SBUF,NODGLOB,WEIGHT,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real
     .   SBUF(*)
       INTEGER WEIGHT(*),NODGLOB(*),NUM,SRECBUF
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      DATA MSGOFF/7011/
      DATA MSGOFF2/7012/
       REAL, DIMENSION(:) , ALLOCATABLE :: BUFSR
       INTEGER, DIMENSION(:) , ALLOCATABLE :: IBUF
Cow Tableau utilise par proc 0
       REAL, DIMENSION(:) , ALLOCATABLE :: XGLOB
C===================================================================
       ALLOCATE(BUFSR(NUMNODM), IBUF(NUMNODM))
       ALLOCATE(XGLOB(NUM))
    
       IF (ISPMD.NE.0) THEN

         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             IBUF(SIZ) = NODGLOB(I)
             BUFSR(SIZ) = SBUF(I)
           END IF
         END DO

Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

         MSGTYP = MSGOFF2 
         CALL MPI_SEND(IBUF,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF 
         CALL MPI_SEND(BUFSR,SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              NG = NODGLOB(I)
              XGLOB(NG) = SBUF(I)
            ENDIF
          ENDDO

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF2

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Cow Reception du buffer flottant des adresses NODGLOB

            MSGTYP = MSGOFF 
            CALL MPI_RECV(BUFSR,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            NREC = SIZ
 
            DO K = 1, NREC
              NG = IBUF(K)
              XGLOB(NG) = BUFSR(K)
            ENDDO
          ENDDO
          CALL WRITE_R_C(XGLOB,NUMNODG)

       ENDIF
       DEALLOCATE(BUFSR,IBUF,XGLOB)

#endif
       RETURN
       END

Chd|====================================================================
Chd|  SPMD_IGATH                    priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        ANISKEW                       src/anim/aniskew.F            
Chd|        ANISKEWF                      src/anim/aniskewf.F           
Chd|        DSPHNOR                       src/anim/dsphnor.F            
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_IGATH(SRBUF,LEN,LRECV)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER SRBUF(*), LEN, LRECV
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGOFF2,MSGTYP,INFO,I,K,ATID,ATAG,ALEN,RLEN,S1
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR
      DATA MSGOFF/7013/
      DATA MSGOFF2/7068/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      S1 = 1
      IF (ISPMD.NE.0) THEN
        MSGTYP=MSGOFF2

        CALL MPI_SEND(LEN,S1,MPI_INTEGER,
     .                IT_SPMD(1),MSGTYP,
     .                MPI_COMM_WORLD,ierror)

        MSGTYP=MSGOFF
        IF(LEN > 0 ) THEN
          CALL MPI_SEND(SRBUF,LEN,MPI_INTEGER,
     .                IT_SPMD(1),MSGTYP,
     .                MPI_COMM_WORLD,ierror)
        ENDIF

      ELSE

        LRECV = LEN

        DO I=2,NSPMD
            MSGTYP=MSGOFF2
            CALL MPI_RECV(RLEN,S1,MPI_INTEGER,
     .                    IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
            MSGTYP=MSGOFF

            IF(RLEN > 0 ) THEN
              ! Even though Receive of length = 0 can cost nothing
              ! SRBUF(LRECV+1) must exist
              CALL MPI_RECV(SRBUF(LRECV+1),RLEN,MPI_INTEGER,
     .                    IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)

            ENDIF
            LRECV = LRECV + RLEN 

        END DO

      ENDIF
C
#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_GATH_COLLECTIVE          priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_GATH_COLLECTIVE(SRBUF,LEN,LRECV)
C Description: 
C Collective communication version of SPMD_IGATH 
C expected to be less efficient than SPMD_IGATH 
C But useful to debug MPI problems: less pending communication 
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER SRBUF(*), LEN, LRECV
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGOFF2,MSGTYP,INFO,I,K,ATID,ATAG,ALEN,RLEN,S1
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR
      INTEGER SIZES(NSPMD),POINTERS(NSPMD)
      INTEGER,ALLOCATABLE,DIMENSION(:) :: SRBUF2
      DATA MSGOFF/7013/
      DATA MSGOFF2/7068/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------

      S1 = 1

      ! Send Local sizes to Zero
      CALL MPI_GATHER(LEN,S1,MPI_INTEGER,SIZES,S1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)


      IF(ISPMD == 0) THEN
        LRECV = 0 
        DO I=1,NSPMD
          LRECV = LRECV + SIZES(I)
        ENDDO
        ! Pointers starts at 0
        POINTERS(1) = 0
        DO I=2,NSPMD
          POINTERS(I) = POINTERS(I-1)+SIZES(I-1)
        ENDDO 
        ALLOCATE(SRBUF2(LRECV))
      ELSE
        ALLOCATE(SRBUF2(1))
      ENDIF

      CALL MPI_GATHERV(SRBUF,LEN,MPI_INTEGER,SRBUF2,SIZES,POINTERS,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)


      CALL MPI_BARRIER(MPI_COMM_WORLD,ierror)

      IF(ISPMD == 0) THEN
        DO I=1,LRECV
          SRBUF(I) = SRBUF2(I)  
        ENDDO 
      ENDIF
      DEALLOCATE(SRBUF2)

C
#endif
      RETURN
      END


Chd|====================================================================
Chd|  SPMD_GATHERF                  priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
       SUBROUTINE SPMD_GATHERF(V,WEIGHT,NODGLOB,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       REAL
     .   V(*)
       INTEGER WEIGHT(*),NODGLOB(*),NUM,SRECBUF
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      DATA MSGOFF/7014/
      DATA MSGOFF2/7015/
       REAL, DIMENSION(:) , ALLOCATABLE :: BUFSR
       INTEGER, DIMENSION(:) , ALLOCATABLE :: IBUF
Cow Tableau utilise par proc 0
       REAL, DIMENSION(:) , ALLOCATABLE :: XGLOB
C===================================================================
       ALLOCATE(BUFSR(NUMNODM), IBUF(NUMNODM))
       ALLOCATE(XGLOB(NUM))
  
          XGLOB = 1000000
          bufsr = 100000      
  
       IF (ISPMD.NE.0) THEN     
         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             IBUF(SIZ) = NODGLOB(I)
             BUFSR(SIZ) = V(I) 
           END IF
         END DO 

Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

         MSGTYP = MSGOFF2
         CALL MPI_SEND(IBUF,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF 
         CALL MPI_SEND(BUFSR,SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          siz = 0
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN 
              siz = siz +1
              NG = NODGLOB(I)
              XGLOB(NG) = V(I)
            ENDIF
          ENDDO

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF2 

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Cow Reception du buffer flottant des adresses NODGLOB

            MSGTYP = MSGOFF 
            CALL MPI_RECV(BUFSR,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            NREC = SIZ
 
            DO K = 1, NREC
              NG = IBUF(K)
              XGLOB(NG) = BUFSR(K)
            ENDDO
          ENDDO
          CALL WRITE_R_C(XGLOB,NUMNODG)

       ENDIF
       DEALLOCATE(BUFSR,IBUF,XGLOB)

#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_GATHERF2                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
       SUBROUTINE SPMD_GATHERF2(V,VGLOB,WEIGHT,NODGLOB,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       REAL
     .   V(*), VGLOB(*)
       INTEGER WEIGHT(*),NODGLOB(*),SRECBUF,NUM
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      DATA MSGOFF/7016/
      DATA MSGOFF2/7017/
       REAL, DIMENSION(:) , ALLOCATABLE :: BUFSR
       INTEGER, DIMENSION(:) , ALLOCATABLE :: IBUF
Cow Tableau utilise par proc 0
       REAL, DIMENSION(:) , ALLOCATABLE :: XGLOB
C===================================================================
       ALLOCATE(BUFSR(NUMNODM), IBUF(NUMNODM))
       ALLOCATE(XGLOB(NUM))   
      
       IF (ISPMD.NE.0) THEN

         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             IBUF(SIZ) = NODGLOB(I)
             BUFSR(SIZ) = V(I) 
           END IF
         END DO

Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

         MSGTYP = MSGOFF2 
         CALL MPI_SEND(IBUF,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF
         CALL MPI_SEND(BUFSR,SIZ,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              NG = NODGLOB(I)
              XGLOB(NG) = V(I)
            ENDIF
          ENDDO

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF2 + I

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Cow Reception du buffer flottant des adresses NODGLOB

            MSGTYP = MSGOFF 
            CALL MPI_RECV(BUFSR,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            NREC = SIZ
 
            DO K = 1, NREC
              NG = IBUF(K)
              XGLOB(NG) = BUFSR(K)
            ENDDO
          ENDDO
          DO I=1,NUMNODG
             XGLOB(I) = XGLOB(I) + VGLOB(I)
          ENDDO
          CALL WRITE_R_C(XGLOB,NUMNODG)

       ENDIF
       DEALLOCATE(BUFSR,IBUF,XGLOB)
       
#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_GATHERITAB               priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|====================================================================
       SUBROUTINE SPMD_GATHERITAB(V,WEIGHT,NODGLOB,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       INTEGER
     .   V(*)
       INTEGER WEIGHT(*),NODGLOB(*),NUM,SRECBUF
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      INTEGER, DIMENSION(:,:) , ALLOCATABLE :: BUFSR 
      INTEGER, DIMENSION(:) , ALLOCATABLE :: XGLOB
C-----------------------------------------------
      DATA MSGOFF/7018/
      DATA MSGOFF2/7019/


C-----------------------------------------------
       ALLOCATE(BUFSR(2,NUMNODM))
       ALLOCATE(XGLOB(NUM))
C-----------------------------------------------
       IF (ISPMD.NE.0) THEN

         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             BUFSR(1,SIZ) = NODGLOB(I)
             BUFSR(2,SIZ) = V(I) 
           END IF
         END DO


         MSGTYP = MSGOFF 
         CALL MPI_SEND(BUFSR,2*SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              NG = NODGLOB(I)
              XGLOB(NG) = V(I)
            ENDIF
          ENDDO

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(BUFSR,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            NREC = SIZ/2
 
            DO K = 1, NREC
              NG = BUFSR(1,K)
              XGLOB(NG) = BUFSR(2,K)
            ENDDO
          ENDDO
          CALL WRITE_I_C(XGLOB,NUMNODG)

       ENDIF
       DEALLOCATE(BUFSR)
       DEALLOCATE(XGLOB)

#endif
       RETURN
       END
C
Chd|====================================================================
Chd|  SPMD_DPARRBY                  priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        SPMD_GLOB_ISUM9               priv/spe/spmd_th.F            
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_DPARRBY(NPBY,LPBY,FR_RBY2,IAD_RBY2,
     .                        SBUFSPM,SBUFRECVM,
     .                        SBUFSPO,SPORBY,
     .                        NODGLOB,WEIGHT,ITAB)


C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
#include      "param_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NPBY(NNPBY,*),LPBY(*),FR_RBY2(3,*),IAD_RBY2(4,*)
      INTEGER SBUFSPM,SBUFRECVM,SBUFSPO,NODGLOB(*),SPORBY,WEIGHT(*),
     .        ITAB(*)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
        INTEGER PMASTER,JENVOIE,I,J,K,L,S,B,M,P,N,
     .          RECOISDE(NSPMD),
     .          II(2),PTRPO(NSPMD+1),PTRPOO(NSPMD+1)
Cow
        INTEGER BUFSEND(NSPMD+1),BUFRECP(NSPMD+1),
     .          NBNOD,SIZ,LPO,NSN,PTR,NOD,NN,NR,
     .          SRBY
        INTEGER, DIMENSION(:), ALLOCATABLE :: BUFSPM,BUFRECVM,PORBY,BUFSPO

        INTEGER MASTERND(NRBYKIN)

Cow MPI variables 
      INTEGER LOC_PROC
      INTEGER MSGOFF,MSGOFF2,MSGTYP,INFO,ATID,ATAG,ALEN
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,ISD(NSPMD)
C-----------------------------------------------
      DATA MSGOFF/7018/
      DATA MSGOFF2/7019/
C-----------------------------------------------
      ALLOCATE(BUFSPM(SBUFSPM))
      ALLOCATE(BUFRECVM(SBUFRECVM+NSPMD+1))
      ALLOCATE(PORBY(SPORBY))
      ALLOCATE(BUFSPO(SBUFSPO))

      LOC_PROC = ISPMD + 1 

C SEND MASTER NODES TO PROC 0
      DO J=1,NRBYKIN
        PMASTER = FR_RBY2(3,J)
        IF (LOC_PROC==ABS(PMASTER))THEN
            MASTERND(J)=NODGLOB( NPBY(1,J) )-1
        ELSE
            MASTERND(J)= 0 
        ENDIF
      ENDDO   

      CALL SPMD_GLOB_ISUM9(MASTERND,NRBYKIN)
Cow init
       DO I=1,SBUFRECVM
           BUFRECVM(I)=0
       ENDDO
Cow Remplissage du buffer d envoi proc ayant des noeuds slaves
Cow vers proc ayant Noeud Master

        L = 1

        DO I=1,NSPMD

          BUFSEND(I)=L
          S = 1
C
          DO J=1,NRBYKIN

            PMASTER = FR_RBY2(3,J)
            NBNOD =  FR_RBY2(1,J)

            IF ( NBNOD.NE.0  .AND.
     .          ABS(PMASTER).EQ.I .AND. LOC_PROC.NE.I) THEN

               BUFSPM(L) = J
               BUFSPM(L+1) = NBNOD
               L = L + 2
               NR = 1
               DO K=1,NPBY(2,J)
                 IF (WEIGHT(LPBY(K+S-1)).EQ.1) THEN
                   BUFSPM(L+NR-1) = NODGLOB(LPBY(K+S-1))-1
                   NR = NR +1
                 ENDIF
               ENDDO
               L = L+NBNOD
            ENDIF
            S = S + NPBY(2,J)
          ENDDO
        ENDDO
        BUFSEND(NSPMD+1)=L

Cow Envoi du buffer BUFSPM vers les differents procs
        DO I=1,NSPMD
  
          IF (IAD_RBY2(1,I).GT.0) THEN

            MSGTYP = MSGOFF
            B = BUFSEND(I)
            SIZ = BUFSEND(I+1)-BUFSEND(I)
            CALL MPI_ISEND(BUFSPM(B),SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .         MPI_COMM_WORLD,ISD(I),ierror)

          ENDIF
        ENDDO

Cow Procs qui contient des Noeuds Master... Reception des noeuds slaves des
Cow differents processeurs

        L=1
        DO I = 1, NSPMD

          BUFRECP(I)=L
          IF (IAD_RBY2(2,I).GT.0) THEN

            MSGTYP = MSGOFF
            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(BUFRECVM(L),SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

            L = L + SIZ
            BUFRECVM(L)=0
            L=L+1
           ENDIF
        ENDDO
        DO I=1,NSPMD
  
          IF (IAD_RBY2(1,I).GT.0) THEN
            CALL MPI_WAIT(ISD(I),STATUS,IERROR)
          ENDIF
        ENDDO
        BUFRECP(NSPMD+1)=L
Cow Maintenant que les procs masters ont tout
Cow Il faut tout compacter dans le tableau d'envoi vers proc0

        L = 0
        K = 1

        DO I=1,NRBYKIN
          PMASTER = FR_RBY2(3,I)

          IF (ABS(PMASTER).EQ.LOC_PROC) THEN

Cow on recopie du proc master les noeuds slaves
               NBNOD = FR_RBY2(1,I)
Cow sauvegarde du ptr pour mettre la taille du RB
               NN = L+1
               L = L+2
               NR = 1

               DO J = 1,NPBY(2,I)
Cow des RBY qui on un PMASTER ngatif n'ont pas forcement tous leur noeuds
Cow avec weight(I)=1
                 IF (PMASTER.LE.0) THEN
                    BUFSPO(L+NR)=NODGLOB(LPBY(K+J-1))-1
                    NR = NR+1
                 ELSE
                   IF (WEIGHT(LPBY(K+J-1)) .EQ.1) THEN
                      BUFSPO(L+NR)=NODGLOB(LPBY(K+J-1))-1
                      NR = NR+1
                   ENDIF
                 ENDIF
               ENDDO

               L=L+NR-1

               SRBY = NR-1

Cow le rb n'est pas local, on parcours les procs pour savoir s'il n a
Cow pas des bouts de RB.
             IF (PMASTER.GT.0) THEN
               DO P=1,NSPMD

                IF (IAD_RBY2(2,P).GT.0) THEN
Cow pointeur courrant de la pile du proc 
                  M = BUFRECP(P)
Cow numero du RB
                  IF (BUFRECVM(M).EQ.I) THEN

                    NBNOD=BUFRECVM(M+1)
                    BUFRECP(P)=BUFRECP(P)+2
Cow recopie
                    NR = 1
                    DO J=BUFRECP(P),BUFRECP(P)+NBNOD-1
                      BUFSPO(L+NR)=BUFRECVM(J)
                      NR=NR+1
                    ENDDO
                    L = L+NR-1
                    SRBY = SRBY + NR-1
Cow mise a jour du pointeur pour le RB suivant
                    BUFRECP(P)=BUFRECP(P)+NBNOD
                  ENDIF
                ENDIF
               ENDDO
             ENDIF
             BUFSPO(NN)=I
             BUFSPO(NN+1)=SRBY
          ENDIF
          K =K+NPBY(2,I)

        ENDDO
Cow envoi tableau vers proc 0
        IF (ISPMD.NE.0 .AND .L.GT.0) THEN

          MSGTYP = MSGOFF2
          CALL MPI_SEND(BUFSPO,L,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .         MPI_COMM_WORLD,ierror)
        ENDIF


Cow je recois des messages des procs qui ont un noeud maitre de RB
        IF (ISPMD.EQ.0) THEN
          DO I=1,NSPMD
            RECOISDE(I)=0
          ENDDO
          DO I=1,NRBYKIN
            RECOISDE(ABS(FR_RBY2(3,I)))=1
          ENDDO

          LPO=1
          PTRPO(1)=LPO
Cow Je remplis ma file pour PO
          DO I=1,L
            PORBY(I)=BUFSPO(I)
          ENDDO
          LPO = LPO+L
          
          DO I=2,NSPMD

            IF (RECOISDE(I).EQ.1) THEN
ccc             
              MSGTYP = MSGOFF2
              PTRPO(I) = LPO
              CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                     MPI_COMM_WORLD,STATUS,ierror)
              CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

              CALL MPI_RECV(PORBY(LPO),SIZ,MPI_INTEGER,IT_SPMD(I),
     .                  MSGTYP, MPI_COMM_WORLD,STATUS,ierror)
              LPO=LPO+SIZ
            ELSE
              PTRPO(I) = LPO
            ENDIF
          ENDDO                
          PTRPO(NSPMD+1)=LPO
Cow ecriture sur disque
           PTRPOO=PTRPO

           DO I=1,NRBYKIN
             II(1)=MASTERND(I)

             DO P=1,NSPMD
               PTR = PTRPO(P)
               IF(PTR<PTRPOO(P+1))THEN
                IF(PORBY(PTR)==I)THEN
                 NSN = PORBY(PTR+1)
                 PTR = PTR+2
                 DO N=1,NSN
                  II(2)=PORBY(PTR+N-1)
                  CALL WRITE_I_C(II,2)
                 ENDDO
                 PTRPO(P)=PTRPO(P) + NSN +2
                ENDIF
               ENDIF
             ENDDO
           ENDDO
        ENDIF

      DEALLOCATE(BUFSPM)
      DEALLOCATE(BUFRECVM)
      DEALLOCATE(PORBY)
      DEALLOCATE(BUFSPO)
#endif
        RETURN
      END

Chd|====================================================================
Chd|  SPMD_DPARRBE2                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        SPMD_GLOB_ISUM9               priv/spe/spmd_th.F            
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_DPARRBE2(LRBE2, IRBE2,NODGLOB,WEIGHT,NERBE2Y,
     *                         NERBE2T )
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
#include      "param_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER IRBE2(NRBE2L,*),LRBE2(*),NODGLOB(*),WEIGHT(*),
     * NERBE2Y,NERBE2T(NRBE2G)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I,N,P
      INTEGER SNRBE2,SIZRBE2,SBUFSIZ,PSNRBE2
      INTEGER NSN,IADG,IAD,SN,MN,NGRBE

      INTEGER,  DIMENSION(:),ALLOCATABLE :: SZLOCRBE2,PGLOBRBE2,MASTERNODS
      INTEGER,  DIMENSION(:),ALLOCATABLE :: SENDBUF,RECBUF,
     *                                      P0RBE2BUF,IADRBE2
      INTEGER,  DIMENSION(:,:),ALLOCATABLE :: P0RECRBE2, IIN

C MPI variables 
      INTEGER LOC_PROC
      INTEGER MSGOFF,MSGOFF2,MSGTYP,INFO,ATID,ATAG,ALEN
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,ISD(NSPMD)

      DATA MSGOFF/7020/
      DATA MSGOFF2/7021/
C-----------------------------------------------
      ALLOCATE(SZLOCRBE2(NRBE2G))
      ALLOCATE(PGLOBRBE2(NRBE2G))
      ALLOCATE(MASTERNODS(NRBE2G))
C-----------------------------------------------
C     1ere etape - envoyer au proc 0 un tableau avec nombre
C                  noeuds slaves locaux par RBE2 a envoyer
C                  et preparation du buffer d envoi
C                  (taille)
      NERBE2T = 0
      SNRBE2 = 0
      SBUFSIZ = 0
      SZLOCRBE2=0
      PGLOBRBE2 = 0

      DO I=1,NRBE2
          NGRBE = IRBE2(10,I)
          SZLOCRBE2(NGRBE) = 0
          NSN = IRBE2(5,I)
          DO N=1,NSN
           IF (WEIGHT(LRBE2(IRBE2(1,I)+N)).EQ.1)
     .       SZLOCRBE2(NGRBE) = SZLOCRBE2(NGRBE)  + 1
          ENDDO
          SBUFSIZ = SBUFSIZ + SZLOCRBE2(NGRBE)

      ENDDO

C Envoi vers le proc 0 du tableau des tailles

      IF (ISPMD == 0) THEN
C Proc zero reception des tailles
        ALLOCATE(P0RECRBE2(NRBE2G,NSPMD))
        DO I=1,NRBE2G
           P0RECRBE2(I,1) = SZLOCRBE2(I)
        ENDDO

        DO P=2,NSPMD
           MSGTYP = MSGOFF
           CALL MPI_RECV(P0RECRBE2(1,P),NRBE2G,MPI_INTEGER,IT_SPMD(P),
     *                   MSGTYP,MPI_COMM_WORLD,STATUS,IERROR)
        ENDDO

      ELSE
C Procs autres envoi
        MSGTYP = MSGOFF
        CALL MPI_SEND(SZLOCRBE2,NRBE2G,MPI_INTEGER,IT_SPMD(1),
     .                MSGTYP,MPI_COMM_WORLD,IERROR)

      ENDIF

C --------------------------------------------------------------
C Envoi vers le proc 0 des noeuds des RBE2 & criture sur disque
C --------------------------------------------------------------
      IF (ISPMD /= 0) THEN
C ------------------------
C Procs autres que proc 0
C ------------------------
         ALLOCATE(SENDBUF(SBUFSIZ))
         SNRBE2 = 0
         DO I=1,NRBE2
           NSN = IRBE2(5,I)
           IAD = IRBE2(1,I)
           DO N=1,NSN
              SN = LRBE2(IAD+N)
              IF (WEIGHT(SN) == 1 )THEN
                SNRBE2 = SNRBE2+1
                SENDBUF(SNRBE2)=NODGLOB(SN)
              ENDIF
           ENDDO
         ENDDO
         IF (SNRBE2 > 0)THEN
           MSGTYP = MSGOFF2
           CALL  MPI_SEND(SENDBUF,SNRBE2,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     *                  MPI_COMM_WORLD,IERROR)
         ENDIF
         DEALLOCATE(SENDBUF)

C Envoi des noeuds slaves
        MASTERNODS = 0
        DO I=1,NRBE2
          MN = IRBE2(3,I)
	  IF(MN.NE.0)THEN
            IF (WEIGHT(MN)==1)THEN
              NGRBE = IRBE2(10,I)
              MASTERNODS(NGRBE)=NODGLOB(MN)
            ENDIF
	  ENDIF
        ENDDO
        CALL SPMD_GLOB_ISUM9(MASTERNODS,NRBE2G)
        

      ELSE
C --------------------------------------------------------------------
C PROC 0
C --------------------------------------------------------------------
C P0RBE2BUF tableau de reception (tableau de reception = LRBE2 Global)
C IADRBE2 pointeurs vers P0RBE2BUF global
         ALLOCATE(IADRBE2(NRBE2G+1))
         ALLOCATE(P0RBE2BUF(NERBE2Y))

C preparation IADRBE2
         IADRBE2(1)=0
         DO I=1,NRBE2G
           SNRBE2 = P0RECRBE2(I,1)
           DO N=2,NSPMD
             SNRBE2 = SNRBE2 + P0RECRBE2(I,N)
           ENDDO
           IADRBE2(I+1)=IADRBE2(I)+SNRBE2
         ENDDO

C preparation P0RECRBE2 pour le proc0
         DO I=1,NRBE2G
	    PGLOBRBE2(I)=IADRBE2(I)
         ENDDO
	 
         DO I=1,NRBE2
           NSN = IRBE2(5,I)
           IAD = IRBE2(1,I)
           NGRBE = IRBE2(10,I)
           IADG = IADRBE2(NGRBE)
           SNRBE2 = 0
           DO N=1,NSN
             SN = LRBE2( IAD+N )
             IF (WEIGHT(SN) == 1 )THEN
               SNRBE2 = SNRBE2+1
               P0RBE2BUF(IADG + SNRBE2) = NODGLOB(SN)
             ENDIF
           ENDDO
           PGLOBRBE2(NGRBE)=PGLOBRBE2(NGRBE) + SNRBE2
         ENDDO

C Reception des RBE2 des autres procs
         DO P=2,NSPMD
C Taille du buffer de reception
           SIZRBE2 = 0
           DO I=1,NRBE2G
             SIZRBE2 = SIZRBE2 + P0RECRBE2(I,P)
           ENDDO

           IF (SIZRBE2 > 0) THEN
             ALLOCATE(RECBUF(SIZRBE2))
             MSGTYP = MSGOFF2 
             CALL MPI_RECV(RECBUF,SIZRBE2,MPI_INTEGER,IT_SPMD(P),MSGTYP,
     *                   MPI_COMM_WORLD,STATUS,IERROR)

             PSNRBE2=0
             DO I=1,NRBE2G
               IADG = PGLOBRBE2(I)
               DO N=1,P0RECRBE2(I,P)
                 PSNRBE2 = PSNRBE2 + 1
                 P0RBE2BUF(IADG + N) = RECBUF(PSNRBE2)
               ENDDO
               PGLOBRBE2(I) = PGLOBRBE2(I) + P0RECRBE2(I,P)
             ENDDO
             DEALLOCATE(RECBUF)
           ENDIF
         ENDDO
C  Reception des Noeuds masters
         MASTERNODS=0
         DO I=1,NRBE2
           MN = IRBE2(3,I)
           IF (WEIGHT(MN)==1) THEN
             NGRBE = IRBE2(10,I)
             MASTERNODS(NGRBE)=NODGLOB(MN)
           ENDIF        
         ENDDO
         CALL SPMD_GLOB_ISUM9(MASTERNODS,NRBE2G)

C Ecriture sur disque
         DO I=1,NRBE2G
           NSN = IADRBE2(I+1) - IADRBE2(I)
           IADG =IADRBE2(I)
           MN = MASTERNODS(I)
           ALLOCATE(IIN(2,NSN))
           NERBE2T(I)=NSN
           DO N=1,NSN
             IIN(1,N)=MN-1
             IIN(2,N)=P0RBE2BUF(IADG + N)-1
           ENDDO
           CALL WRITE_I_C(IIN,2*NSN)
           DEALLOCATE(IIN)
         ENDDO
         DEALLOCATE(IADRBE2)
         DEALLOCATE(P0RBE2BUF)
         DEALLOCATE(P0RECRBE2)
      ENDIF


      DEALLOCATE(SZLOCRBE2)
      DEALLOCATE(PGLOBRBE2)
      DEALLOCATE(MASTERNODS)

#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_DPARRBE3                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        SPMD_GLOB_ISUM9               priv/spe/spmd_th.F            
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_DPARRBE3(LRBE3, IRBE3,NODGLOB,WEIGHT,NERBE3Y,
     *                         NERBE3T )
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
#include      "param_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER IRBE3(NRBE3L,*),LRBE3(*),NODGLOB(*),WEIGHT(*),
     * NERBE3Y,NERBE3T(NRBE3G)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I,N,P
      INTEGER SNRBE3,SIZRBE3,SBUFSIZ,PSNRBE3
      INTEGER NSN,IADG,IAD,SN,MN,NGRBE

      INTEGER, DIMENSION(:),ALLOCATABLE :: SLAVENODS,SZLOCRBE3,PGLOBRBE3

      INTEGER,  DIMENSION(:),ALLOCATABLE :: SENDBUF,RECBUF,
     *                                      P0RBE3BUF,IADRBE3
      INTEGER,  DIMENSION(:,:),ALLOCATABLE :: P0RECRBE3, IIN

C MPI variables 
      INTEGER LOC_PROC
      INTEGER MSGOFF,MSGOFF2,MSGTYP,INFO,ATID,ATAG,ALEN
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,ISD(NSPMD)

      DATA MSGOFF/7022/
      DATA MSGOFF2/7023/
C-----------------------------------------------
      ALLOCATE(SLAVENODS(NRBE3G))
      ALLOCATE(SZLOCRBE3(NRBE3G))
      ALLOCATE(PGLOBRBE3(NRBE3G))
C-----------------------------------------------
C     1ere etape - envoyer au proc 0 un tableau avec nombre
C                  noeuds master locaux par RBE3 a envoyer
C                  et preparation du buffer d envoi
C                  (taille)
      NERBE3T = 0
      SNRBE3 = 0
      SBUFSIZ = 0
      SZLOCRBE3 = 0

      DO I=1,NRBE3
          NGRBE = IRBE3(10,I)
          SZLOCRBE3(NGRBE) = 0
          NSN = IRBE3(5,I)
          DO N=1,NSN
           IF (WEIGHT(LRBE3(IRBE3(1,I)+N)).EQ.1)
     .       SZLOCRBE3(NGRBE) = SZLOCRBE3(NGRBE)  + 1
          ENDDO
          SBUFSIZ = SBUFSIZ + SZLOCRBE3(NGRBE)
      ENDDO
C Envoi vers le proc 0 du tableau des tailles

      IF (ISPMD == 0) THEN
C Proc zero reception des tailles
        ALLOCATE(P0RECRBE3(NRBE3G,NSPMD))
        DO I=1,NRBE3G
           P0RECRBE3(I,1) = SZLOCRBE3(I)
        ENDDO

        DO P=2,NSPMD
           MSGTYP = MSGOFF 
           CALL MPI_RECV(P0RECRBE3(1,P),NRBE3G,MPI_INTEGER,IT_SPMD(P),
     *                   MSGTYP,MPI_COMM_WORLD,STATUS,IERROR)
        ENDDO


      ELSE
C Procs autres envoi
        MSGTYP = MSGOFF 
        CALL MPI_SEND(SZLOCRBE3,NRBE3G,MPI_INTEGER,IT_SPMD(1),
     .                MSGTYP,MPI_COMM_WORLD,IERROR)

      ENDIF


C --------------------------------------------------------------
C Envoi vers le proc 0 des noeuds des RBE3 & criture sur disque
C --------------------------------------------------------------
      IF (ISPMD /= 0) THEN
C ------------------------
C Procs autres que proc 0
C ------------------------
         ALLOCATE(SENDBUF(SBUFSIZ))
         SNRBE3 = 0
         DO I=1,NRBE3
           NSN = IRBE3(5,I)
           IAD = IRBE3(1,I)
           DO N=1,NSN
              SN = LRBE3(IAD+N)
              IF (WEIGHT(SN) == 1 )THEN
                SNRBE3 = SNRBE3+1
                SENDBUF(SNRBE3)=NODGLOB(SN)
              ENDIF
           ENDDO
         ENDDO
         IF (SNRBE3 > 0)THEN
           MSGTYP = MSGOFF2
           CALL  MPI_SEND(SENDBUF,SNRBE3,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     *                  MPI_COMM_WORLD,IERROR)
         ENDIF
         DEALLOCATE(SENDBUF)

C Envoi des noeuds slaves
        SLAVENODS=0
         DO I=1,NRBE3
           MN =  IRBE3(3,I)
	   IF(MN.NE.0)THEN
             IF (WEIGHT(MN)==1) THEN
               NGRBE = IRBE3(10,I)
               SLAVENODS(NGRBE)=NODGLOB(MN)
             ENDIF        
           ENDIF        
         ENDDO
         CALL SPMD_GLOB_ISUM9(SLAVENODS,NRBE3G)

      ELSE
C --------------------------------------------------------------------
C PROC 0
C --------------------------------------------------------------------
C P0RBE3BUF tableau de reception (tableau de reception = LRBE3 Global)
C IADRBE3 pointeurs vers P0RBE3BUF global
         ALLOCATE(IADRBE3(NRBE3G+1))
         ALLOCATE(P0RBE3BUF(NERBE3Y))

C preparation IADRBE3
         IADRBE3(1)=0
         DO I=1,NRBE3G
           SNRBE3 = P0RECRBE3(I,1)
           DO N=2,NSPMD
             SNRBE3 = SNRBE3 + P0RECRBE3(I,N)
           ENDDO
           IADRBE3(I+1)=IADRBE3(I)+SNRBE3
         ENDDO

C preparation P0RECRBE3 pour le proc0
         PGLOBRBE3=0
         DO I=1,NRBE3G
	    PGLOBRBE3(I)=IADRBE3(I)
         ENDDO
	 	 
         DO I=1,NRBE3
           NSN = IRBE3(5,I)
           IAD = IRBE3(1,I)
           NGRBE = IRBE3(10,I)
           IADG = IADRBE3(NGRBE)
           SNRBE3 = 0
           DO N=1,NSN
             SN = LRBE3( IAD+N )
             IF (WEIGHT(SN) == 1 )THEN
               SNRBE3 = SNRBE3+1
               P0RBE3BUF(IADG + SNRBE3) = NODGLOB(SN)
             ENDIF
           ENDDO
           PGLOBRBE3(NGRBE)= PGLOBRBE3(NGRBE) + SNRBE3
         ENDDO

C Reception des RBE3 des autres procs
         DO P=2,NSPMD
C Taille du buffer de reception
           SIZRBE3 = 0
           DO I=1,NRBE3G
             SIZRBE3 = SIZRBE3 + P0RECRBE3(I,P)
           ENDDO
           IF (SIZRBE3 > 0) THEN
             ALLOCATE(RECBUF(SIZRBE3))
             MSGTYP = MSGOFF2
             CALL MPI_RECV(RECBUF,SIZRBE3,MPI_INTEGER,IT_SPMD(P),MSGTYP,
     *                   MPI_COMM_WORLD,STATUS,IERROR)

             PSNRBE3=0
             DO I=1,NRBE3G
               IADG = PGLOBRBE3(I)
               DO N=1,P0RECRBE3(I,P)
                 PSNRBE3 = PSNRBE3 + 1
                 P0RBE3BUF(IADG + N) = RECBUF(PSNRBE3)
               ENDDO
               PGLOBRBE3(I) = PGLOBRBE3(I) + P0RECRBE3(I,P)
             ENDDO
             DEALLOCATE(RECBUF)
           ENDIF
         ENDDO
C Reception des Noeuds slaves
         SLAVENODS=0
         DO I=1,NRBE3
           MN =  IRBE3(3,I)
           IF (WEIGHT(MN)==1) THEN
             NGRBE = IRBE3(10,I)
             SLAVENODS(NGRBE)=NODGLOB(MN)
           ENDIF        
         ENDDO
         CALL SPMD_GLOB_ISUM9(SLAVENODS,NRBE3G)

C Ecriture sur disque
         DO I=1,NRBE3G
           NSN = IADRBE3(I+1) - IADRBE3(I)
           IADG =IADRBE3(I)
           MN = SLAVENODS(I)
           ALLOCATE(IIN(2,NSN))
           NERBE3T(I)=NSN
           DO N=1,NSN
             IIN(1,N)=MN-1
             IIN(2,N)=P0RBE3BUF(IADG + N)-1
           ENDDO
           CALL WRITE_I_C(IIN,2*NSN)
           DEALLOCATE(IIN)
         ENDDO
         DEALLOCATE(IADRBE3)
         DEALLOCATE(P0RBE3BUF)
         DEALLOCATE(P0RECRBE3)
      ENDIF

C-----------------------------------------------
      DEALLOCATE(SLAVENODS)
      DEALLOCATE(SZLOCRBE3)
      DEALLOCATE(PGLOBRBE3)

#endif
      RETURN
      END
C-----------------------------------------------
C-----------------------------------------------
Chd|====================================================================
Chd|  SPMD_VELVEC2                  priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        VELVEC2                       src/anim/velvec.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_VELVEC2(V,NODGLOB,RBUF,NUMPOG)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NODGLOB(*),RBUF,NUMPOG

      my_real 
     .   V(3,*)

C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,J,K,NG,NREC,MSGOFF2
      my_real
     .     R1,R2,R3

      INTEGER, DIMENSION(:), ALLOCATABLE ::  NGLOBI
      my_real,
     *    DIMENSION(:,:),ALLOCATABLE :: VRECV
      REAL, DIMENSION(:,:),ALLOCATABLE :: VTOTAL


      DATA MSGOFF/7024/
      DATA MSGOFF2/7025/
C-----------------------------------------------
       ALLOCATE(NGLOBI(RBUF))
       ALLOCATE(VRECV(3,RBUF))
       ALLOCATE(VTOTAL(3,NUMPOG))

       IF (ISPMD.NE.0) THEN
Cow on envoie le nodglob
         MSGTYP = MSGOFF

         CALL MPI_SEND(NODGLOB,NUMNOD,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

         MSGTYP = MSGOFF2
         CALL MPI_SEND(V,3*NUMNOD,REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          DO I=1,NUMNODG
            VTOTAL(1,I) = ZERO
            VTOTAL(2,I) = ZERO
            VTOTAL(3,I) = ZERO
          ENDDO

          DO I=1,NUMNOD
            K = NODGLOB(I)
            VTOTAL(1,K)= VTOTAL(1,K) + V(1,I)
            VTOTAL(2,K)= VTOTAL(2,K) + V(2,I)
            VTOTAL(3,K)= VTOTAL(3,K) + V(3,I)
          ENDDO
          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF 

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(NGLOBI,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            MSGTYP = MSGOFF2
            CALL MPI_RECV(VRECV,3*SIZ,REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
 
            DO J = 1, SIZ
              K = NGLOBI(J)
              VTOTAL(1,K)= VTOTAL(1,K) + VRECV(1,J)
              VTOTAL(2,K)= VTOTAL(2,K) + VRECV(2,J)
              VTOTAL(3,K)= VTOTAL(3,K) + VRECV(3,J)
            ENDDO
          ENDDO
          CALL WRITE_R_C(VTOTAL,3*NUMNODG)

       ENDIF

       DEALLOCATE(NGLOBI)
       DEALLOCATE(VRECV)
       
#endif
       RETURN
       END

Chd|====================================================================
Chd|  SPMD_WRT_XYZNOD               priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        XYZNOD                        src/anim/xyznod.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
       SUBROUTINE SPMD_WRT_XYZNOD(X,WEIGHT,NODGLOB,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real
     .   X(3,*)
       INTEGER WEIGHT(*),NODGLOB(*),NUM,SRECBUF
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2,SI,MSGTYP2

      REAL, DIMENSION(:,:), ALLOCATABLE :: BUFSR,XGLOB
      INTEGER, DIMENSION(:), ALLOCATABLE :: IBUF

      DATA MSGOFF/7026/
      DATA MSGOFF2/7027/
       
C-----------------------------------------------

       ALLOCATE(BUFSR(3,NUMNODM))
       ALLOCATE(XGLOB(3,NUM))
       ALLOCATE(IBUF(NUMNODM))
        
       IF (ISPMD.NE.0) THEN

         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             IBUF(SIZ) = NODGLOB(I)
             BUFSR(1,SIZ) = X(1,I)
             BUFSR(2,SIZ) = X(2,I) 
             BUFSR(3,SIZ) = X(3,I) 
           END IF
         END DO

Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

         MSGTYP = MSGOFF2 
         CALL MPI_SEND(IBUF,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

Cow
         MSGTYP = MSGOFF
         CALL MPI_SEND(BUFSR,3*SIZ,MPI_REAL4,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)


       ELSE

          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              NG = NODGLOB(I)
              XGLOB(1,NG) = X(1,I)
              XGLOB(2,NG) = X(2,I)
              XGLOB(3,NG) = X(3,I)
            ENDIF
          ENDDO


          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF2

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Cow Reception du buffer flottant des adresses NODGLOB

            MSGTYP2 = MSGOFF 

            CALL MPI_RECV(BUFSR,SIZ*3,MPI_REAL4,IT_SPMD(I),MSGTYP2,
     .                  MPI_COMM_WORLD,STATUS,ierror)
         
            NREC = SIZ 


            DO K = 1, NREC
              NG = IBUF(K)
              XGLOB(1,NG) = BUFSR(1,K)
              XGLOB(2,NG) = BUFSR(2,K)
              XGLOB(3,NG) = BUFSR(3,K)
            ENDDO
          ENDDO
Cow
Cow 
          DO I=1,NUMNODG
           CALL WRITE_R_C(XGLOB(1,I),1)
           CALL WRITE_R_C(XGLOB(2,I),1)
           CALL WRITE_R_C(XGLOB(3,I),1)
         END DO
        END IF


       DEALLOCATE(BUFSR)
       DEALLOCATE(XGLOB)
       DEALLOCATE(IBUF)

#endif
       RETURN
       END


Chd|====================================================================
Chd|  SPMD_IGLOB_PARTN              priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        PARSOR0                       src/anim/parsor0.F            
Chd|        PARSORC                       src/anim/parsorc.F            
Chd|        PARSORF                       src/anim/parsorf.F            
Chd|        PARSORS                       src/anim/parsors.F            
Chd|        PARSOR_CRK                    src/anim/parsor_crk.F         
Chd|        PARSOR_PLY                    src/anim/parsor_ply.F         
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_IGLOB_PARTN(IAD,NBPART,IADG,SBUF)
C iglob_part reconstruit sur p0 un tableau global de part 
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER IAD(*), NBPART, IADG(NSPMD,NBPART)
      INTEGER SBUF
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGTYP,INFO,K,N,NB_TMP
      INTEGER, DIMENSION(:),ALLOCATABLE :: RECBUF
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR

      DATA MSGOFF/7028/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(RECBUF(SBUF))

      IF (ISPMD.NE.0) THEN
         MSGTYP= MSGOFF
         CALL MPI_SEND(IAD,NBPART,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .                MPI_COMM_WORLD,ierror)

      ELSE
        DO N = 1, NBPART
          IADG(1,N) = IAD(N)
        ENDDO

        DO K=2,NSPMD
          MSGTYP= MSGOFF
          CALL MPI_PROBE(IT_SPMD(K),MSGTYP,
     .                   MPI_COMM_WORLD,STATUS,ierror)
          CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,NB_TMP,ierror)
          CALL MPI_RECV(RECBUF,NB_TMP,MPI_INTEGER,IT_SPMD(K),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

          DO N = 1, NBPART
            IADG(K,N) = RECBUF(N)
          ENDDO
        END DO
      ENDIF

      DEALLOCATE(RECBUF)

#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_IGET_PARTN               priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        ANIOFF0                       src/anim/anioff0.F            
Chd|        ANIOFFC                       src/anim/anioffc.F            
Chd|        ANIOFFC_CRK                   src/anim/anioffc_crk.F        
Chd|        ANIOFFC_PLY                   src/anim/anioffc_ply.F        
Chd|        ANIOFFF                       src/anim/aniofff.F            
Chd|        ANIOFFS                       src/anim/anioff6.F            
Chd|        DELNUMB0                      src/anim/delnumb0.F           
Chd|        DELNUMBC                      src/anim/delnumbc.F           
Chd|        DELNUMBC_CRK                  src/anim/delnumbc_crk.F       
Chd|        DELNUMBF                      src/anim/delnumbf.F           
Chd|        DELNUMBS                      src/anim/delnumb6.F           
Chd|        PARSOR0                       src/anim/parsor0.F            
Chd|        PARSORC                       src/anim/parsorc.F            
Chd|        PARSORF                       src/anim/parsorf.F            
Chd|        PARSORS                       src/anim/parsors.F            
Chd|        PARSOR_CRK                    src/anim/parsor_crk.F         
Chd|-- calls ---------------
Chd|        WRITE_C_C                     src/sortie/sortie_c.c         
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_IGET_PARTN(SIZE,NBF_L,NP,NBPART,IADG,SRBUF,IFLAG)
C gather sur p0 du tableau wa en fonction des parts (IADG)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------

#ifdef MPI
#include "mpif.h"
#endif

C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NBF_L, NP(*),IADG(NSPMD,*),SIZE
      INTEGER  NBPART, IFLAG,SRBUF
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGTYP,INFO,IDEB,K,N,NB_TMP,LEN,IADP(NSPMD),I

      INTEGER STATUS(MPI_STATUS_SIZE),IERROR
      INTEGER, DIMENSION(:),ALLOCATABLE :: RBUF,NPT
      DATA MSGOFF/7029/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(RBUF(SRBUF+1))
      ALLOCATE(NPT(NBF_L))

      IF (ISPMD.NE.0) THEN
        MSGTYP= MSGOFF

        CALL MPI_SEND(NP,NBF_L,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .                MPI_COMM_WORLD,ierror)

      ELSE
        DO K=1,NBF_L
           RBUF(K) = NP(K)
        ENDDO
        IDEB = NBF_L +  1
        IADP(1) = 1
C
      DO K=2,NSPMD
        IADP(K) = IDEB
        MSGTYP= MSGOFF

         CALL MPI_PROBE(IT_SPMD(K),MSGTYP,
     .                   MPI_COMM_WORLD,STATUS,ierror)
         CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,NB_TMP,ierror)

         CALL MPI_RECV(RBUF(IDEB),NB_TMP,MPI_INTEGER,IT_SPMD(K),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

        IDEB = IDEB + NB_TMP
        END DO
C
        DO N = 1, NBPART
          DO K = 1, NSPMD
            IF (N.GT.1) THEN
              LEN = (IADG(K,N) - IADG(K,N-1))*SIZE
            ELSE
              LEN = IADG(K,N)*SIZE
            ENDIF

            IF (IFLAG.EQ.1) THEN
              IF(LEN>0)CALL WRITE_I_C(RBUF(IADP(K)),LEN)
            ELSEIF(IFLAG.EQ.2) THEN
              IF(LEN>0)CALL WRITE_C_C(RBUF(IADP(K)),LEN)
            ENDIF
            IADP(K) = IADP(K) + LEN
          ENDDO
        ENDDO
      ENDIF
C
      DEALLOCATE(RBUF)
      DEALLOCATE(NPT)
#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_WRT_XYZNOR               priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        XYZNOR                        src/anim/xyznor.F             
Chd|-- calls ---------------
Chd|        WRITE_S_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_WRT_XYZNOR(XNORM,WEIGHT,NODGLOB,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "scr14_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real
     .   XNORM(3,*)
       INTEGER WEIGHT(*),NODGLOB(*),NUM,SRECBUF
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      INTEGER, DIMENSION(:,:), ALLOCATABLE :: IBUF,RNGLOB
      DATA MSGOFF/7030/
      DATA MSGOFF2/7031/
       
Cow Tableau utilise par proc 0
       my_real
     . S3000,S,XN1,XN2,XN3,IXNN
C-----------------------------------------------
       ALLOCATE(IBUF(4,NUMNODM))
       ALLOCATE(RNGLOB(3,NUM))

       S3000 = TROIS1000         


       IXNN = S3000
       IF(FMT_ANI.EQ.4)IXNN=0

       IF (ISPMD.NE.0) THEN

         SIZ = 0
         DO I=1,NUMNOD
           IF (WEIGHT(I).EQ.1) THEN
             SIZ = SIZ + 1
             IBUF(1,SIZ) = NODGLOB(I)
             S = SQRT(XNORM(1,I)**2 + XNORM(2,I)**2 + XNORM(3,I)**2)
             IF(S.NE.ZERO)THEN
               S = S3000 / S
               XN1 = XNORM(1,I) * S
               XN2 = XNORM(2,I) * S
               XN3 = XNORM(3,I) * S
               IBUF(2,SIZ) = XN1
               IBUF(3,SIZ) = XN2
               IBUF(4,SIZ) = XN3
             ELSE
               IBUF(2,SIZ) = 0
               IBUF(3,SIZ) = 0
               IBUF(4,SIZ) = IXNN
             END IF
           END IF
         END DO

Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

        MSGTYP = MSGOFF2 
        CALL MPI_SEND(IBUF,4*SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE
          DO I=1,NUMNOD
            IF (WEIGHT(I).EQ.1) THEN
              NG = NODGLOB(I)
              S = SQRT(XNORM(1,I)**2 + XNORM(2,I)**2 + XNORM(3,I)**2)
              IF(S.NE.ZERO)THEN
               S = S3000 / S
               XN1 = XNORM(1,I) * S
               XN2 = XNORM(2,I) * S
               XN3 = XNORM(3,I) * S
               RNGLOB(1,NG) = XN1
               RNGLOB(2,NG) = XN2
               RNGLOB(3,NG) = XN3
              ELSE
               RNGLOB(1,NG) = 0
               RNGLOB(2,NG) = 0
               RNGLOB(3,NG) = IXNN
              END IF 
            END IF
          ENDDO

          DO I=2,NSPMD

            MSGTYP = MSGOFF2

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
            CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

         
            NREC = SIZ/4

            DO K = 1, NREC
              NG = IBUF(1,K)
              RNGLOB(1,NG) = IBUF(2,K)
              RNGLOB(2,NG) = IBUF(3,K)
              RNGLOB(3,NG) = IBUF(4,K)
            ENDDO
          ENDDO

          CALL WRITE_S_C(RNGLOB,3*NUMNODG)

       ENDIF

       DEALLOCATE(IBUF)
       DEALLOCATE(RNGLOB)

#endif
       RETURN
       END

Cgw          DXYZSECT                /anim/dxyzsect.F
Cgw          DXWALL                  /anim/dxwall.F
Chd|====================================================================
Chd|  SPMD_AGET_SECT                priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        DXYZSECT                      src/anim/dxyzsect.F           
Chd|-- calls ---------------
Chd|====================================================================
       SUBROUTINE SPMD_AGET_SECT(NSTRF,X,XSEC,WEIGHT,ITAB)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include "implicit_f.inc"
#include "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
#include "com04_c.inc"
#include "task_c.inc"
#include      "com01_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real 
     .    XSEC(3,3,NSECT),X(3,*)
       INTEGER NSTRF(*),WEIGHT(*),ITAB(*)
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER IERROR,
     .        STATUS(MPI_STATUS_SIZE)

       my_real
     .    XSECTMP(3,3,NSECT)

       INTEGER I,K1,N1,N2,N3,LEN

         DO I=1,NSECT
            XSECTMP(1,1,I)=ZERO
            XSECTMP(1,2,I)=ZERO
            XSECTMP(1,3,I)=ZERO

            XSECTMP(2,1,I)=ZERO
            XSECTMP(2,2,I)=ZERO
            XSECTMP(2,3,I)=ZERO

            XSECTMP(3,1,I)=ZERO
            XSECTMP(3,2,I)=ZERO
            XSECTMP(3,3,I)=ZERO

            XSEC(1,1,I)=ZERO
            XSEC(1,2,I)=ZERO
            XSEC(1,3,I)=ZERO

            XSEC(2,1,I)=ZERO
            XSEC(2,2,I)=ZERO
            XSEC(2,3,I)=ZERO

            XSEC(3,1,I)=ZERO
            XSEC(3,2,I)=ZERO
            XSEC(3,3,I)=ZERO

         ENDDO

         K1 = 33

         DO I=1,NSECT
            N1 = NSTRF(K1+1)
            N2 = NSTRF(K1+2)
            N3 = NSTRF(K1+3)
            IF (N1.GT.0) THEN
              IF (WEIGHT(N1).EQ.1) THEN
                XSECTMP(1,1,I) = X(1,N1)
                XSECTMP(1,2,I) = X(2,N1)
                XSECTMP(1,3,I) = X(3,N1)
              ENDIF
            ENDIF

            IF (N2.GT.0) THEN
              IF (WEIGHT(N2).EQ.1) THEN
                XSECTMP(2,1,I) = X(1,N2)
                XSECTMP(2,2,I) = X(2,N2)
                XSECTMP(2,3,I) = X(3,N2)
              ENDIF
            ENDIF

            IF (N3.GT.0) THEN
              IF (WEIGHT(N3).EQ.1) THEN
                XSECTMP(3,1,I) = X(1,N3)
                XSECTMP(3,2,I) = X(2,N3)
                XSECTMP(3,3,I) = X(3,N3)
              ENDIF
            ENDIF

            K1= NSTRF(K1+22)+2
         ENDDO
         
           LEN = 9*NSECT

          
           CALL MPI_REDUCE(XSECTMP,XSEC,LEN,
     .                  REAL,MPI_SUM,IT_SPMD(1),
     .                  MPI_COMM_WORLD,IERROR)


Cow
Cow         IF (ISPMD.EQ.0) THEN
Cow           DO I=1,NSECT
Cow             print*,I,'XSEC N1= ',XSEC(1,1,I),XSEC(1,2,I),XSEC(1,3,I)
Cow             print*,I,'XSEC N2= ',XSEC(2,1,I),XSEC(2,2,I),XSEC(2,3,I)
Cow             print*,I,'XSEC N2= ',XSEC(3,1,I),XSEC(3,2,I),XSEC(3,3,I)
Cow             print*,' ' 
Cow           ENDDO
Cow         ENDIF
#endif
       RETURN
       END


Cgw          DXYZSECT                /anim/dxyzsect.F
Cgw          DXWALL                  /anim/dxwall.F
Chd|====================================================================
Chd|  SPMD_AGETMSR                  priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        DXWALC                        src/anim/dxwalc.F             
Chd|        DXWALL                        src/anim/dxwall.F             
Chd|        DXWALP                        src/anim/dxwalp.F             
Chd|        DXWALS                        src/anim/dxwals.F             
Chd|        DXYZSECT                      src/anim/dxyzsect.F           
Chd|-- calls ---------------
Chd|====================================================================
        SUBROUTINE SPMD_AGETMSR(FR_WALL,X,MSR,XWL,YWL,ZWL,RWL)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       my_real
     .   X(3,*),XWL,YWL,ZWL,RWL(*)
       INTEGER MSR,FR_WALL(NSPMD+2)
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
       INTEGER P
       INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF,MSGTYP
       my_real
     .         XYZWL(3) 
       DATA MSGOFF/7032/

       P = FR_WALL(NSPMD+2)
       IF (P.EQ.1.OR.P.EQ.0) THEN
         IF (ISPMD.EQ.0) THEN
           IF (MSR.EQ.0) THEN
              XWL = RWL(4) 
              YWL = RWL(5)
              ZWL = RWL(6)
           ELSE
             XWL = X(1,MSR)
             YWL = X(2,MSR)
             ZWL = X(3,MSR)
           END IF
         END IF
       ELSE
         IF (P.EQ.ISPMD+1) THEN
           IF (MSR.EQ.0) THEN
             XWL = RWL(4) 
             YWL = RWL(5)
             ZWL = RWL(6)
           ELSE
             XYZWL(1)= X(1,MSR)
             XYZWL(2)= X(2,MSR)
             XYZWL(3)= X(3,MSR)
           END IF

           MSGTYP = MSGOFF 
           CALL MPI_SEND(XYZWL,3,REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)
         END IF
         IF (ISPMD.EQ.0) THEN
            MSGTYP = MSGOFF 
            CALL MPI_RECV(XYZWL,3,REAL,IT_SPMD(P),MSGTYP,
     .              MPI_COMM_WORLD,STATUS,ierror)
            XWL = XYZWL(1)
            YWL = XYZWL(2) 
            ZWL = XYZWL(3) 
         END IF
       END IF
#endif
      RETURN
      END      

Cgw          XYZ16                  /anim/genani.F
Chd|====================================================================
Chd|  SPMD_GATHER_XYZ16             priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        XYZ16                         src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_GATHER_XYZ16(V,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include      "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       real
     .   V(3,*)
       INTEGER NUM
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      DATA MSGOFF/7033/

Cow Tableau utilise par proc 0
       REAL
     .   XGLOB(3,NUM)
         
       IF (ISPMD.NE.0) THEN
         MSGTYP = MSGOFF 
         CALL MPI_SEND(V,6*NUMELS16,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE

          CALL WRITE_R_C(V,6*NUMELS16)

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF 

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(XGLOB,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

            CALL WRITE_R_C(XGLOB,SIZ)
          ENDDO

       ENDIF

#endif
       RETURN
       END

Cgw          dxyzsph                  /anim/dxyzsph.F
Chd|====================================================================
Chd|  SPMD_GATHER_SPH               priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        DXYZSPH                       src/anim/dxyzsph.F            
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|====================================================================
      SUBROUTINE SPMD_GATHER_SPH(V,TV,NUM)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include      "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       real
     .   V(*)
       INTEGER NUM,TV
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2

      DATA MSGOFF/7034/

Cow Tableau utilise par proc 0
       REAL, DIMENSION(:),ALLOCATABLE :: XGLOB
C-----------------------------------------------
       ALLOCATE(XGLOB(NUM))
         
       IF (ISPMD.NE.0) THEN
         MSGTYP = MSGOFF
         CALL MPI_SEND(V,3*TV,MPI_REAL,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE

          CALL WRITE_R_C(V,3*TV)

          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(XGLOB,SIZ,MPI_REAL,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

Cow
           
            CALL WRITE_R_C(XGLOB,SIZ)
          ENDDO

       ENDIF

       DEALLOCATE(XGLOB)

#endif
       RETURN
       END

Chd|====================================================================
Chd|  SPMD_EXCH_NODAREA             priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        ADMTHKE                       src/remesh/admthke.F          
Chd|        ANI_PCONT                     src/anim/ani_pcont.F          
Chd|        ANI_PCONT21                   src/anim/ani_pcont.F          
Chd|        ERR_THK                       src/error/err_thk.F           
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_EXCH_NODAREA(
     .           NODAREA,IAD_ELEM,FR_ELEM,LENR,WEIGHT)
C realise la sommation des aires aux noeuds frontieres
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER  IAD_ELEM(2,*),FR_ELEM(*), SIZE, LENR,WEIGHT(*)
      my_real 
     .        NODAREA(*)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGTYP,I,NOD,LOC_PROC,IERROR,
     .        SIZ,J,K,L,NB_NOD,
     .        STATUS(MPI_STATUS_SIZE),
     .        IAD_SEND(NSPMD+1),IAD_RECV(NSPMD+1),
     .        REQ_R(NSPMD),REQ_S(NSPMD),MSGOFF

      my_real,
     .  DIMENSION(:),ALLOCATABLE ::  SBUF,RBUF
      DATA MSGOFF/7035/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(SBUF(LENR))
      ALLOCATE(RBUF(LENR))
C-----------------------------------------------

      LOC_PROC = ISPMD+1
      L = 1
      IAD_RECV(1)=1

Cow Mise en place des buffers de reception
      DO I=1,NSPMD
         SIZ = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
         IF(SIZ.NE.0) THEN
           MSGTYP = MSGOFF
           CALL MPI_IRECV(
     S      RBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_R(I),IERROR)
           L = L+SIZ
         END IF
         IAD_RECV(I+1) = L
      END DO

Cow Remplissage des buffers d'envoi et envoi des donnees
C
      L=1
      IAD_SEND(1)=1
      DO I=1,NSPMD
         DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1
            NOD = FR_ELEM(J)
            SBUF(L) = NODAREA(NOD)
            L = L+1
         END DO
        IAD_SEND(I+1) = L
      END DO

      DO I=1,NSPMD

       IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN

          
          MSGTYP = MSGOFF
          SIZ = IAD_SEND(I+1)-IAD_SEND(I)
          L = IAD_SEND(I)

          CALL MPI_ISEND(
     S      SBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_S(I),IERROR)
       ENDIF                
      END DO
Cow Reception et traitement
      DO I = 1, NSPMD
C
        NB_NOD = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
        IF(NB_NOD.GT.0)THEN
          CALL MPI_WAIT(REQ_R(I),STATUS,IERROR)
          L = IAD_RECV(I)

          DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1

             NOD = FR_ELEM(J)
             NODAREA(NOD) = NODAREA(NOD) + RBUF(L)
             L = L+1
          ENDDO
        ENDIF
      ENDDO

      DO I = 1, NSPMD
        IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN
          CALL MPI_WAIT(REQ_S(I),STATUS,IERROR)
        ENDIF
      ENDDO
C
C Mise a 0 de adm sur noeud non maitre
C
C      DO I = 1, NUMNOD
C        IF(WEIGHT(I).EQ.0) ADM(I) = ZERO
C      ENDDO
C
      DEALLOCATE(SBUF)
      DEALLOCATE(RBUF)

#endif
      RETURN
      END



Chd|====================================================================
Chd|  SPMD_EXCH_NODAREA2            priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_EXCH_NODAREA2(
     .           NODAREA,IAD_ELEM,FR_ELEM,LENR,WEIGHT,JJ)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER  IAD_ELEM(2,*),FR_ELEM(*), SIZE, LENR,WEIGHT(*),JJ
      my_real 
     .        NODAREA(3,*)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGTYP,I,NOD,LOC_PROC,IERROR,
     .        SIZ,J,K,L,NB_NOD,
     .        STATUS(MPI_STATUS_SIZE),
     .        IAD_SEND(NSPMD+1),IAD_RECV(NSPMD+1),
     .        REQ_R(NSPMD),REQ_S(NSPMD),MSGOFF

      my_real,
     . DIMENSION(:),ALLOCATABLE :: SBUF,RBUF
      DATA MSGOFF/7035/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(SBUF(LENR))
      ALLOCATE(RBUF(LENR))
C-----------------------------------------------
      LOC_PROC = ISPMD+1
      L = 1
      IAD_RECV(1)=1

Cow Mise en place des buffers de reception
      DO I=1,NSPMD
         SIZ = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
         IF(SIZ.NE.0) THEN
           MSGTYP = MSGOFF
           CALL MPI_IRECV(
     S      RBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_R(I),IERROR)
           L = L+SIZ
         END IF
         IAD_RECV(I+1) = L
      END DO

! Remplissage des buffers d'envoi et envoi des donnees
C
      L=1
      IAD_SEND(1)=1
      DO I=1,NSPMD
         DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1
            NOD = FR_ELEM(J)
            SBUF(L) = NODAREA(JJ,NOD)
            L = L+1
         END DO
        IAD_SEND(I+1) = L
      END DO

      DO I=1,NSPMD

       IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN

          
          MSGTYP = MSGOFF
          SIZ = IAD_SEND(I+1)-IAD_SEND(I)
          L = IAD_SEND(I)

          CALL MPI_ISEND(
     S      SBUF(L),SIZ,REAL,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_S(I),IERROR)
       ENDIF                
      END DO
! Reception et traitement
      DO I = 1, NSPMD
C
        NB_NOD = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
        IF(NB_NOD.GT.0)THEN
          CALL MPI_WAIT(REQ_R(I),STATUS,IERROR)
          L = IAD_RECV(I)

          DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1

             NOD = FR_ELEM(J)
             NODAREA(JJ,NOD) = NODAREA(JJ,NOD) + RBUF(L)
             L = L+1
          ENDDO
        ENDIF
      ENDDO

      DO I = 1, NSPMD
        IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN
          CALL MPI_WAIT(REQ_S(I),STATUS,IERROR)
        ENDIF
      ENDDO
C-----------------------------------------------
      DEALLOCATE(SBUF)
      DEALLOCATE(RBUF)
C-----------------------------------------------
#endif
      RETURN
      END


Chd|====================================================================
Chd|  SPMD_EXCH_NODAREAI            priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_EXCH_NODAREAI(
     .           NODAREAI,IAD_ELEM,FR_ELEM,LENR,WEIGHT)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER  IAD_ELEM(2,*),FR_ELEM(*), SIZE, LENR,WEIGHT(*)
      INTEGER  NODAREAI(*)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGTYP,I,NOD,LOC_PROC,IERROR,
     .        SIZ,J,K,L,NB_NOD,
     .        STATUS(MPI_STATUS_SIZE),
     .        IAD_SEND(NSPMD+1),IAD_RECV(NSPMD+1),
     .        REQ_R(NSPMD),REQ_S(NSPMD),MSGOFF

      INTEGER, DIMENSION(:),ALLOCATABLE :: SBUF,RBUF
      DATA MSGOFF/7035/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(SBUF(LENR))
      ALLOCATE(RBUF(LENR))
C-----------------------------------------------
      LOC_PROC = ISPMD+1
      L = 1
      IAD_RECV(1)=1

Cow Mise en place des buffers de reception
      DO I=1,NSPMD
         SIZ = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
         IF(SIZ.NE.0) THEN
           MSGTYP = MSGOFF
           CALL MPI_IRECV(
     S      RBUF(L),SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_R(I),IERROR)
           L = L+SIZ
         END IF
         IAD_RECV(I+1) = L
      END DO

! Remplissage des buffers d'envoi et envoi des donnees

      L=1
      IAD_SEND(1)=1
      DO I=1,NSPMD
         DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1
            NOD = FR_ELEM(J)
            SBUF(L) = NODAREAI(NOD)
            L = L+1
         END DO
        IAD_SEND(I+1) = L
      END DO

      DO I=1,NSPMD

       IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN

          
          MSGTYP = MSGOFF
          SIZ = IAD_SEND(I+1)-IAD_SEND(I)
          L = IAD_SEND(I)

          CALL MPI_ISEND(
     S      SBUF(L),SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     G      MPI_COMM_WORLD,REQ_S(I),IERROR)
       ENDIF                
      END DO
! Reception et traitement
      DO I = 1, NSPMD
C
        NB_NOD = IAD_ELEM(1,I+1)-IAD_ELEM(1,I)
        IF(NB_NOD.GT.0)THEN
          CALL MPI_WAIT(REQ_R(I),STATUS,IERROR)
          L = IAD_RECV(I)

          DO J=IAD_ELEM(1,I),IAD_ELEM(1,I+1)-1

             NOD = FR_ELEM(J)
             NODAREAI(NOD) = NODAREAI(NOD) + RBUF(L)
             L = L+1
          ENDDO
        ENDIF
      ENDDO

      DO I = 1, NSPMD
        IF(IAD_ELEM(1,I+1)-IAD_ELEM(1,I).GT.0)THEN
          CALL MPI_WAIT(REQ_S(I),STATUS,IERROR)
        ENDIF
      ENDDO
C-----------------------------------------------
      DEALLOCATE(SBUF)
      DEALLOCATE(RBUF)
C-----------------------------------------------
#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_FVB_AMON                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_AMON(MONVOL, VOLMON)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
#include      "param_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER MONVOL(*)
      my_real
     .        VOLMON(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER K1, KK1, KIBALE, KRBALE, IFV, N, ITYP, PMASTER, NN, NTG,
     .        ITAG, MSGOFF, LEN, IERR, STAT(MPI_STATUS_SIZE), IAD,
     .        I,MSGTAG
      my_real
     .       , DIMENSION(:), ALLOCATABLE :: RBUF
      DATA MSGOFF/7036/
C
      K1=1
      KK1=1
      KIBALE=1+NIMV*NVOLU+LICBAG+LIBAGJET+LIBAGHOL
      KRBALE=1+NRVOLU*NVOLU+LRCBAG+LRBAGJET+LRBAGHOL
      IFV=0
      DO N=1,NVOLU
         ITYP=MONVOL(K1-1+2)
         IF (ITYP.EQ.6.OR.ITYP.EQ.8) THEN
           IFV =MONVOL(K1-1+45)
           PMASTER=FVSPMD(IFV)%PMASTER
           IF (PMASTER.NE.1) THEN
C
            NN =MONVOL(K1-1+32)+MONVOL(K1-1+68)
            NTG=MONVOL(K1-1+33)+MONVOL(K1-1+69)
            MSGTAG=MSGOFF
            LEN=6*NN+2*NTG
            ALLOCATE(RBUF(LEN))
            IF (ISPMD.EQ.0) THEN
C Proc 0 recoit
               CALL MPI_RECV(RBUF, LEN, REAL, IT_SPMD(PMASTER),
     .                       MSGTAG, MPI_COMM_WORLD, STAT, IERR)
C
               IAD=KRBALE+MONVOL(K1-1+34)
               DO I=1,6*NN
                  VOLMON(IAD+I-1)=RBUF(I)
               ENDDO
               IAD=IAD+6*NN+NTG
               DO I=1,2*NTG
                  VOLMON(IAD+I-1)=RBUF(6*NN+I)
               ENDDO
            ELSEIF (ISPMD.EQ.PMASTER-1) THEN
C Proc master envoie
               IAD=KRBALE+MONVOL(K1-1+34)
               DO I=1,6*NN
                  RBUF(I)=VOLMON(IAD+I-1)
               ENDDO
               IAD=IAD+6*NN+NTG
               DO I=1,2*NTG
                  RBUF(6*NN+I)=VOLMON(IAD+I-1)
               ENDDO
C
               CALL MPI_SEND(RBUF, LEN, REAL, IT_SPMD(1),
     .                       MSGTAG, MPI_COMM_WORLD,  IERR)
            ENDIF
            DEALLOCATE(RBUF)             
           ENDIF
         ENDIF
         K1=K1+NIMV
         KK1=KK1+NRVOLU
      ENDDO
C
#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_FVB_ADIM                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_ADIM(NFVTR, FVOFF , NFVNOD, NFVPART, NFVSUBS,
     .                         IDMAX, ITAB  , NODCUT, NNWL   , NNSRG  ,
     .                         NNSMD, NNSPHG)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NFVTR, FVOFF(2,*), NFVNOD, NFVPART, NFVSUBS, IDMAX,
     .        ITAB(*), NODCUT, NNWL, NNSRG, NNSMD, NNSPHG
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER IDMAXL, I, ITAG, MSGOFF, IDMAXP(NSPMD-1), 
     .        REQ(NSPMD-1), IERR, STAT(MPI_STATUS_SIZE,NSPMD-1),
     .        PMASTER, TAB(4),MSGTYP
      DATA MSGOFF/7037/
C
      IDMAXL=0
      DO I=1,NUMNOD
         IDMAXL=MAX(IDMAXL,ITAB(I))
      ENDDO
      IF (ISPMD.EQ.0) THEN
         DO I=1,NSPMD-1
            MSGTYP=MSGOFF
            CALL MPI_IRECV(IDMAXP(I), 1, MPI_INTEGER, IT_SPMD(I+1),
     .                     MSGTYP, MPI_COMM_WORLD, REQ(I), IERR)
         ENDDO
         CALL MPI_WAITALL(NSPMD-1, REQ, STAT, IERR)
C
         IDMAX=IDMAXL
         DO I=1,NSPMD-1
            IDMAX=MAX(IDMAX,IDMAXP(I))
         ENDDO
      ELSE
         MSGTYP=MSGOFF
         CALL MPI_ISEND(IDMAXL, 1, MPI_INTEGER, IT_SPMD(1),
     .                  MSGTYP, MPI_COMM_WORLD, REQ, IERR)
         CALL MPI_WAIT(REQ, STAT, IERR)
      ENDIF
C
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               NFVTR=NFVTR+FVDATA(I)%NNTR
               FVOFF(1,I)=NUMNODG+NODCUT+NSECT+NRWALL+NNWL
     .                   +NNSRG+NNSMD+NNSPHG+2*NUMELS16G+NFVNOD
               FVOFF(2,I)=IDMAX+NFVNOD
               NFVNOD=NFVNOD+FVDATA(I)%NNS_ANIM
               NFVPART=NFVPART+FVDATA(I)%NPOLH_ANIM
               NFVSUBS=NFVSUBS+1
            ELSE
               MSGTYP=MSGOFF
               CALL MPI_RECV(TAB, 3, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       MSGTYP, MPI_COMM_WORLD, STAT, IERR)
C
               NFVTR=NFVTR+TAB(1)
               FVOFF(1,I)=NUMNODG+NODCUT+NSECT+NRWALL+NNWL
     .                   +NNSRG+NNSMD+NNSPHG+2*NUMELS16G+NFVNOD
               FVOFF(2,I)=IDMAX+NFVNOD
               NFVNOD=NFVNOD+TAB(2)
               NFVPART=NFVPART+TAB(3)
               NFVSUBS=NFVSUBS+1
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               MSGTYP=MSGOFF
               TAB(1)=FVDATA(I)%NNTR
               TAB(2)=FVDATA(I)%NNS_ANIM
               TAB(3)=FVDATA(I)%NPOLH_ANIM
               CALL MPI_SEND(TAB, 3, MPI_INTEGER, IT_SPMD(1),
     .                       MSGTYP, MPI_COMM_WORLD,  IERR)
            ENDIF
         ENDIF
      ENDDO
C
      IF (ISPMD.EQ.0) THEN
         TAB(1)=NFVTR
         TAB(2)=NFVNOD
         TAB(3)=NFVPART
         TAB(4)=NFVSUBS
      ENDIF
      CALL MPI_BCAST(TAB, 4, MPI_INTEGER, IT_SPMD(1),
     .               MPI_COMM_WORLD, IERR)
      IF (ISPMD.NE.0) THEN
         NFVTR=TAB(1)
         NFVNOD=TAB(2)
         NFVPART=TAB(3)
         NFVSUBS=TAB(4)
      ENDIF
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_ANOD                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_ANOD()
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I, PMASTER, J, ITAG, MSGOFF, STAT(MPI_STATUS_SIZE),
     .        IERR, LEN, NNS_ANIM, JJ,MSGOFF2
      my_real
     .       , DIMENSION(:), ALLOCATABLE :: RBUF
      REAL R4
C-----------------------------------------------
      DATA MSGOFF/7038/
      DATA MSGOFF2/7039/
C-----------------------------------------------
C
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               DO J=1,FVDATA(I)%NNS_ANIM
                  R4=FVDATA(I)%NOD_ANIM(1,J)
                  CALL WRITE_R_C(R4,1)
                  R4=FVDATA(I)%NOD_ANIM(2,J)
                  CALL WRITE_R_C(R4,1)
                  R4=FVDATA(I)%NOD_ANIM(3,J)
                  CALL WRITE_R_C(R4,1)
               ENDDO
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NNS_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(PMASTER), ITAG, MPI_COMM_WORLD,
     .                       STAT, IERR)
C
               LEN=3*NNS_ANIM
               ALLOCATE(RBUF(LEN))
               ITAG=MSGOFF2
               CALL MPI_RECV(RBUF, LEN, REAL, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               DO J=1,LEN
                  R4=RBUF(J)
                  CALL WRITE_R_C(R4,1)
               ENDDO
               DEALLOCATE(RBUF)
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_SEND(FVDATA(I)%NNS_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD, 
     .                       IERR)
C
               LEN=3*FVDATA(I)%NNS_ANIM
               ALLOCATE(RBUF(LEN))
               JJ=0
               DO J=1,FVDATA(I)%NNS_ANIM
                  JJ=JJ+1
                  RBUF(JJ)=FVDATA(I)%NOD_ANIM(1,J)
                  JJ=JJ+1
                  RBUF(JJ)=FVDATA(I)%NOD_ANIM(2,J)
                  JJ=JJ+1
                  RBUF(JJ)=FVDATA(I)%NOD_ANIM(3,J)
               ENDDO
               ITAG=MSGOFF2
               CALL MPI_SEND(RBUF, LEN, REAL, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD,  IERR)
C
               DEALLOCATE(RBUF)
            ENDIF
         ENDIF
      ENDDO         
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_ATR                  priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_ATR(NBID1, NBID2, NBID3, FVEL2FA, FVINUM,
     .                        FVOFF)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NBID1, NBID2, NBID3, FVEL2FA(*), FVINUM(*), FVOFF(2,*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER ELOFF, I, PMASTER, II, J, K, KK, N, NN, INOD(4), NND,
     .        ITAG, MSGOFF, LEN, JJ, IAD, IADE, IADF,
     .        STAT(MPI_STATUS_SIZE), IERR, NNTR
      INTEGER, DIMENSION(:), ALLOCATABLE :: ITAGT, IBUF
C-----------------------------------------------
      DATA MSGOFF/7040/
C-----------------------------------------------
C
      ELOFF=0
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               ALLOCATE(ITAGT(FVDATA(I)%NNTR))
               II=0
               DO J=1,FVDATA(I)%NNTR
                  ITAGT(J)=0
               ENDDO
C
               DO J=1,FVDATA(I)%NPOLH_ANIM
                  DO K=FVDATA(I)%IFVPADR_ANIM(J),
     .                      FVDATA(I)%IFVPADR_ANIM(J+1)-1
                     KK=FVDATA(I)%IFVPOLH_ANIM(K)
                     DO N=FVDATA(I)%IFVTADR_ANIM(KK),
     .                         FVDATA(I)%IFVTADR_ANIM(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY_ANIM(N)
                        IF (ITAGT(NN).EQ.1) CYCLE
                        INOD(1)=FVOFF(1,I)+FVDATA(I)%IFVTRI_ANIM(1,NN)-1
                        INOD(2)=FVOFF(1,I)+FVDATA(I)%IFVTRI_ANIM(2,NN)-1
                        INOD(3)=FVOFF(1,I)+FVDATA(I)%IFVTRI_ANIM(3,NN)-1
                        INOD(4)=INOD(3)
                        II=II+1
C Nombre de noeuds distincts de la coque (apres fusion dans FVMESH)
                        NND=1
                        IF (INOD(2).NE.INOD(1)) NND=NND+1
                        IF (INOD(3).NE.INOD(1).AND.
     .                      INOD(3).NE.INOD(2)) NND=NND+1
                        IF (NND.NE.3) THEN
                           INOD(1)=NBID1-1
                           INOD(2)=NBID2-1
                           INOD(3)=NBID3-1
                           INOD(4)=INOD(3)
                        ENDIF
C 
                        CALL WRITE_I_C(INOD,4)
                        ITAGT(NN)=1
                        FVEL2FA(ELOFF+NN)=ELOFF+II
                        FVINUM(ELOFF+II)=ELOFF+NN
                     ENDDO
                  ENDDO
               ENDDO
               ELOFF=ELOFF+FVDATA(I)%NNTR
               DEALLOCATE(ITAGT)
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NNTR, 1, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               LEN=6*NNTR
               ALLOCATE(IBUF(LEN))
               ITAG=MSGOFF+1
               CALL MPI_RECV(IBUF, LEN, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               JJ=0
               DO J=1,NNTR
                  INOD(1)=FVOFF(1,I)+IBUF(JJ+1)
                  INOD(2)=FVOFF(1,I)+IBUF(JJ+2)
                  INOD(3)=FVOFF(1,I)+IBUF(JJ+3)
                  INOD(4)=FVOFF(1,I)+IBUF(JJ+4)
C
C Nombre de noeuds distincts de la coque (apres fusion dans FVMESH)
                  NND=1
                  IF (INOD(2).NE.INOD(1)) NND=NND+1
                  IF (INOD(3).NE.INOD(1).AND.
     .                INOD(3).NE.INOD(2)) NND=NND+1
                  IF (NND.NE.3) THEN
                     INOD(1)=NBID1-1
                     INOD(2)=NBID2-1
                     INOD(3)=NBID3-1
                     INOD(4)=INOD(3)
                  ENDIF
C
                  CALL WRITE_I_C(INOD,4)
                  JJ=JJ+4
C
                  FVEL2FA(ELOFF+J)=ELOFF+IBUF(4*NNTR+J)
                  FVINUM(ELOFF+J)=ELOFF+IBUF(5*NNTR+J)
               ENDDO
               ELOFF=ELOFF+NNTR
               DEALLOCATE(IBUF)
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_SEND(FVDATA(I)%NNTR, 1, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD,
     .                       IERR)
C
               LEN=6*FVDATA(I)%NNTR
               ALLOCATE(IBUF(LEN), ITAGT(FVDATA(I)%NNTR))
               II=0
               IAD=0
               IADE=4*FVDATA(I)%NNTR
               IADF=IADE+FVDATA(I)%NNTR
C
               DO J=1,FVDATA(I)%NNTR
                  ITAGT(J)=0
               ENDDO
C
               DO J=1,FVDATA(I)%NPOLH_ANIM
                  DO K=FVDATA(I)%IFVPADR_ANIM(J),
     .                      FVDATA(I)%IFVPADR_ANIM(J+1)-1
                     KK=FVDATA(I)%IFVPOLH_ANIM(K)
                     DO N=FVDATA(I)%IFVTADR_ANIM(KK),
     .                         FVDATA(I)%IFVTADR_ANIM(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY_ANIM(N)
                        IF (ITAGT(NN).EQ.1) CYCLE
                        INOD(1)=FVDATA(I)%IFVTRI_ANIM(1,NN)-1
                        INOD(2)=FVDATA(I)%IFVTRI_ANIM(2,NN)-1
                        INOD(3)=FVDATA(I)%IFVTRI_ANIM(3,NN)-1
                        INOD(4)=INOD(3)
                        II=II+1
C 
                        IBUF(IAD+1)=INOD(1)
                        IBUF(IAD+2)=INOD(2)
                        IBUF(IAD+3)=INOD(3)
                        IBUF(IAD+4)=INOD(4)
                        IAD=IAD+4
                        ITAGT(NN)=1
                        IBUF(IADE+NN)=II
                        IBUF(IADF+II)=NN
                     ENDDO
                  ENDDO
               ENDDO
               ITAG=MSGOFF+1
               CALL MPI_SEND(IBUF, LEN, MPI_INTEGER, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD, IERR)
C
               DEALLOCATE(IBUF, ITAGT)
            ENDIF
         ENDIF
      ENDDO
C
#endif
      RETURN
      END      
Chd|====================================================================
Chd|  SPMD_FVB_AOFF                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_C_C                     src/sortie/sortie_c.c         
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_AOFF(FVEL2FA)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER FVEL2FA(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER ELOFF, I, PMASTER, J, K, KK, N, NN, N1, N2, N3, NND,
     .        ITAG, NNTR, IERR, STAT(MPI_STATUS_SIZE), JJ, IAD,
     .        LEN, MSGOFF,MSGOFF2
      INTEGER, DIMENSION(:), ALLOCATABLE :: OFFTR, IBUF, ITAGT
C-----------------------------------------------
      DATA MSGOFF/7041/
      DATA MSGOFF2/7042/
C-----------------------------------------------
C
      ELOFF=0
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               ALLOCATE(OFFTR(FVDATA(I)%NNTR))
               DO J=1,FVDATA(I)%NNTR
                  OFFTR(J)=0
               ENDDO
               DO J=1,FVDATA(I)%NPOLH
                  DO K=FVDATA(I)%IFVPADR(J),FVDATA(I)%IFVPADR(J+1)-1
                     KK=FVDATA(I)%IFVPOLH(K)
                     DO N=FVDATA(I)%IFVTADR(KK),
     .                         FVDATA(I)%IFVTADR(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY(N)
                        IF (NN.GT.0) THEN
                           N1=FVDATA(I)%IFVTRI_ANIM(1,NN)
                           N2=FVDATA(I)%IFVTRI_ANIM(2,NN)
                           N3=FVDATA(I)%IFVTRI_ANIM(3,NN)
                           NND=1
                           IF (N2.NE.N1) NND=NND+1
                           IF (N3.NE.N2.AND.N3.NE.N1) NND=NND+1
C
                           NN=FVEL2FA(ELOFF+NN)-ELOFF
                           IF (NND.EQ.3) OFFTR(NN)=1
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
               ELOFF=ELOFF+FVDATA(I)%NNTR
               CALL WRITE_C_C(OFFTR,FVDATA(I)%NNTR)
               DEALLOCATE(OFFTR)
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NNTR, 1, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               LEN=2*NNTR
               ALLOCATE(IBUF(LEN), OFFTR(NNTR))
               ITAG=MSGOFF2
               CALL MPI_RECV(IBUF, LEN, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               DO J=1,NNTR
                  OFFTR(J)=0
               ENDDO
               JJ=0
               DO J=1,NNTR
                  NN=IBUF(JJ+1)
                  IF (NN .NE.0 ) THEN
                    NN=FVEL2FA(ELOFF+NN)-ELOFF
                    OFFTR(NN)=IBUF(JJ+2)
                  ENDIF
                  JJ=JJ+2
               ENDDO
               ELOFF=ELOFF+NNTR
               CALL WRITE_C_C(OFFTR,NNTR)
               DEALLOCATE(IBUF, OFFTR)
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_SEND(FVDATA(I)%NNTR, 1, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD,
     .                       IERR)
C
               LEN=2*FVDATA(I)%NNTR
               ALLOCATE(IBUF(LEN), ITAGT(FVDATA(I)%NNTR))
               DO J=1,LEN
                  IBUF(J)=0
               ENDDO
               DO J=1,FVDATA(I)%NNTR
                  ITAGT(J)=0
               ENDDO
               IAD=0
               DO J=1,FVDATA(I)%NPOLH
                  DO K=FVDATA(I)%IFVPADR(J),FVDATA(I)%IFVPADR(J+1)-1
                     KK=FVDATA(I)%IFVPOLH(K)
                     DO N=FVDATA(I)%IFVTADR(KK),
     .                         FVDATA(I)%IFVTADR(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY(N)
                        IF (NN.GT.0.AND.ITAGT(NN).EQ.0) THEN
                           N1=FVDATA(I)%IFVTRI_ANIM(1,NN)
                           N2=FVDATA(I)%IFVTRI_ANIM(2,NN)
                           N3=FVDATA(I)%IFVTRI_ANIM(3,NN)
                           NND=1
                           IF (N2.NE.N1) NND=NND+1
                           IF (N3.NE.N2.AND.N3.NE.N1) NND=NND+1
C
                           IBUF(IAD+1)=NN
                           IF (NND.EQ.3) IBUF(IAD+2)=1
                           IAD=IAD+2
                           ITAGT(NN)=1
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
               ITAG=MSGOFF2
               CALL MPI_SEND(IBUF, LEN, MPI_INTEGER, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD,  IERR)
C
               DEALLOCATE(IBUF, ITAGT)              
            ENDIF
         ENDIF
      ENDDO
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_APAR                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_APAR(NELCUT, NBF   , NESCT, NERWL, NESRG,
     .                         NESMD1, FVPBUF)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NELCUT, NBF, NESCT, NERWL, NESRG, NESMD1, FVPBUF(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER FVIAD, I, PMASTER, J, K, KK, N, NN, ITAG, MSGOFF,MSGOFF2,
     .        NPOLH_ANIM, IERR, STAT(MPI_STATUS_SIZE), IAD, IADP
C-----------------------------------------------
      INTEGER, DIMENSION(:), ALLOCATABLE :: ITAGT, IBUF
C-----------------------------------------------
      DATA MSGOFF/7043/
      DATA MSGOFF2/7044/
C
      IADP=0
      FVIAD=NELCUT+NBF+NESCT+NERWL+NESRG+NESMD1
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               ALLOCATE(ITAGT(FVDATA(I)%NNTR))
               DO J=1,FVDATA(I)%NNTR
                  ITAGT(J)=0
               ENDDO
C
               DO J=1,FVDATA(I)%NPOLH_ANIM
                  DO K=FVDATA(I)%IFVPADR_ANIM(J),
     .                        FVDATA(I)%IFVPADR_ANIM(J+1)-1
                     KK=FVDATA(I)%IFVPOLH_ANIM(K)
                     DO N=FVDATA(I)%IFVTADR_ANIM(KK),
     .                          FVDATA(I)%IFVTADR_ANIM(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY_ANIM(N)
                        IF (ITAGT(NN).EQ.0) THEN
                           FVIAD=FVIAD+1
                           ITAGT(NN)=1
                        ENDIF
                     ENDDO
                  ENDDO
                  FVPBUF(IADP+J)=FVIAD
               ENDDO
               IADP=IADP+FVDATA(I)%NPOLH_ANIM
C
               DEALLOCATE(ITAGT)
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NPOLH_ANIM, 1, MPI_INTEGER, 
     .                       IT_SPMD(PMASTER), ITAG, MPI_COMM_WORLD,
     .                       STAT, IERR)
C
               ALLOCATE(IBUF(NPOLH_ANIM))
               ITAG=MSGOFF2
               CALL MPI_RECV(IBUF, NPOLH_ANIM, MPI_INTEGER,
     .                       IT_SPMD(PMASTER), ITAG, MPI_COMM_WORLD,
     .                       STAT, IERR)
C
               DO J=1,NPOLH_ANIM
                  FVPBUF(IADP+J)=FVIAD+IBUF(J)
               ENDDO
               FVIAD=FVIAD+IBUF(NPOLH_ANIM)
               IADP=IADP+NPOLH_ANIM
               DEALLOCATE(IBUF)
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_SEND(FVDATA(I)%NPOLH_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD,
     .                       IERR)
C
               ALLOCATE(IBUF(FVDATA(I)%NPOLH_ANIM), 
     .                       ITAGT(FVDATA(I)%NNTR))
               IAD=0
C
               DO J=1,FVDATA(I)%NNTR
                  ITAGT(J)=0
               ENDDO
C
               DO J=1,FVDATA(I)%NPOLH_ANIM
                  DO K=FVDATA(I)%IFVPADR_ANIM(J),
     .                        FVDATA(I)%IFVPADR_ANIM(J+1)-1
                     KK=FVDATA(I)%IFVPOLH_ANIM(K)
                     DO N=FVDATA(I)%IFVTADR_ANIM(KK),
     .                          FVDATA(I)%IFVTADR_ANIM(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY_ANIM(N)
                        IF (ITAGT(NN).EQ.0) THEN
                           IAD=IAD+1
                           ITAGT(NN)=1
                        ENDIF
                     ENDDO
                  ENDDO
                  IBUF(J)=IAD
               ENDDO
               ITAG=MSGOFF2
               CALL MPI_SEND(IBUF, FVDATA(I)%NPOLH_ANIM, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD,
     .                        IERR)
C
               DEALLOCATE(IBUF, ITAGT)                              
            ENDIF
         ENDIF
      ENDDO
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_ATIT                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_C_C                     src/sortie/sortie_c.c         
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_ATIT(CTEXT, STR, TITL, LTITL,MAXPART)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER CTEXT(*), LTITL,MAXPART
      CHARACTER*(*) STR, TITL
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I, PMASTER, J, K, ITAG, MSGOFF, NPOLH_ANIM,
     .        STAT(MPI_STATUS_SIZE), IERR
C-----------------------------------------------
      DATA MSGOFF/7045/
C
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               DO J=1,FVDATA(I)%NPOLH_ANIM
                  WRITE(STR,'(I9,A1)') J+MAXPART,':'
                  DO K=1,10
                     CTEXT(K)=ICHAR(STR(K:K))
                  ENDDO
                  TITL=' '
                  WRITE(TITL,'(A11,I9)') 'POLYHEDRON ',J
                  DO K=1,LTITL
                     CTEXT(K+10)=ICHAR(TITL(K:K))
                  ENDDO
                  CTEXT(31)=0
                  CALL WRITE_C_C(CTEXT,10+LTITL)
               ENDDO
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NPOLH_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(PMASTER), ITAG, MPI_COMM_WORLD,
     .                       STAT, IERR)
               DO J=1,NPOLH_ANIM
                  WRITE(STR,'(I8,A1)') J+MAXPART,':'
                  DO K=1,10
                     CTEXT(K)=ICHAR(STR(K:K))
                  ENDDO
                  TITL=' '
                  WRITE(TITL,'(A11,I9)') 'POLYHEDRON ',J
                  DO K=1,LTITL
                     CTEXT(K+10)=ICHAR(TITL(K:K))
                  ENDDO
                  CTEXT(31)=0
                  CALL WRITE_C_C(CTEXT,10+LTITL)
               ENDDO
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_SEND(FVDATA(I)%NPOLH_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD,
     .                       IERR)
            ENDIF
         ENDIF
         MAXPART = MAXPART + FVDATA(I)%NPOLH_ANIM
      ENDDO              
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_AELF                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_AELF(FVMASS , FVPRES, FVQX  , FVQY  , FVQZ  ,
     .                         FVRHO  , FVENER, FVCSON, FVGAMA, FVVISU,
     .                         FVEL2FA)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER FVEL2FA(*)
      my_real
     .        FVMASS(*), FVPRES(*), FVQX(*), FVQY(*), FVQZ(*), FVRHO(*),
     .        FVENER(*), FVCSON(*), FVGAMA(*), FVVISU(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER ELOFF, I, PMASTER, J, K, KK, N, NN, IDP, ITAG, MSGOFF,
     .        NNTR, LEN, IAD, STAT(MPI_STATUS_SIZE), IERR,MSGOFF2
      my_real
     .        GAMA, SSP, FAC
      my_real
     .       , DIMENSION(:), ALLOCATABLE :: RBUF
      DATA MSGOFF/7046/
      DATA MSGOFF2/7047/

C
      ELOFF=0
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               DO J=1,FVDATA(I)%NPOLH
                  GAMA=FVDATA(I)%GPOLH(J)
                  SSP=SQRT((GAMA-UN)*GAMA*FVDATA(I)%EPOLH(J)/
     .                                    FVDATA(I)%MPOLH(J))
                  DO K=FVDATA(I)%IFVPADR(J),FVDATA(I)%IFVPADR(J+1)-1
                     KK=FVDATA(I)%IFVPOLH(K)
                     DO N=FVDATA(I)%IFVTADR(KK),
     .                         FVDATA(I)%IFVTADR(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY(N)
                        FAC=UN
                        IF (FVDATA(I)%IFVTRI(4,NN).NE.0) THEN
                           IDP=FVDATA(I)%IDPOLH(J)
                           FVVISU(FVEL2FA(ELOFF+NN))=IDP-(IDP/8)*8+1
                        ELSE
                           FVVISU(FVEL2FA(ELOFF+NN))=-1
                           FAC=UNDEMI
                        ENDIF
                        NN=FVEL2FA(ELOFF+NN)
                        FVMASS(NN)=FVMASS(NN)+FAC*FVDATA(I)%MPOLH(J)
                        FVPRES(NN)=FVPRES(NN)+FAC*FVDATA(I)%PPOLH(J)
                        IF (FVDATA(I)%MPOLH(J).GT.ZERO) THEN
                           FVQX(NN)=FVQX(NN)+FAC*FVDATA(I)%QPOLH(1,J)/
     .                                           FVDATA(I)%MPOLH(J)
                           FVQY(NN)=FVQY(NN)+FAC*FVDATA(I)%QPOLH(2,J)/
     .                                           FVDATA(I)%MPOLH(J)
                           FVQZ(NN)=FVQZ(NN)+FAC*FVDATA(I)%QPOLH(3,J)/
     .                                           FVDATA(I)%MPOLH(J)
                           FVENER(NN)=FVENER(NN)+FAC*FVDATA(I)%EPOLH(J)/
     .                                               FVDATA(I)%MPOLH(J)
                        ENDIF
                        FVRHO(NN)=FVRHO(NN)+FAC*FVDATA(I)%RPOLH(J)
                        FVCSON(NN)=FVCSON(NN)+FAC*SSP
                        FVGAMA(NN)=FVGAMA(NN)+FAC*GAMA
                     ENDDO
                  ENDDO
               ENDDO
               ELOFF=ELOFF+FVDATA(I)%NNTR
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NNTR, 1, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               LEN=10*NNTR
               ALLOCATE(RBUF(LEN))
               ITAG=MSGOFF2
               CALL MPI_RECV(RBUF, LEN, REAL, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               DO J=1,NNTR
                  NN=FVEL2FA(ELOFF+J)
                  FVMASS(NN)=RBUF(J)
                  FVPRES(NN)=RBUF(NNTR+J)
                  FVQX(NN)=RBUF(2*NNTR+J)
                  FVQY(NN)=RBUF(3*NNTR+J)
                  FVQZ(NN)=RBUF(4*NNTR+J)
                  FVENER(NN)=RBUF(5*NNTR+J)
                  FVRHO(NN)=RBUF(6*NNTR+J)
                  FVCSON(NN)=RBUF(7*NNTR+J)
                  FVGAMA(NN)=RBUF(8*NNTR+J)
                  FVVISU(NN)=RBUF(9*NNTR+J)
               ENDDO
               ELOFF=ELOFF+NNTR
               DEALLOCATE(RBUF)
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               NNTR=FVDATA(I)%NNTR
               ITAG=MSGOFF
               CALL MPI_SEND(NNTR, 1, MPI_INTEGER, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD, IERR)
C
               LEN=10*NNTR
               ALLOCATE(RBUF(LEN))
               DO J=1,LEN
                  RBUF(J)=ZERO
               ENDDO
               DO J=1,FVDATA(I)%NPOLH
                  GAMA=FVDATA(I)%GPOLH(J)
                  SSP=SQRT((GAMA-UN)*GAMA*FVDATA(I)%EPOLH(J)/
     .                                    FVDATA(I)%MPOLH(J))
                  DO K=FVDATA(I)%IFVPADR(J),FVDATA(I)%IFVPADR(J+1)-1
                     KK=FVDATA(I)%IFVPOLH(K)
                     DO N=FVDATA(I)%IFVTADR(KK),
     .                         FVDATA(I)%IFVTADR(KK+1)-1
                        NN=FVDATA(I)%IFVPOLY(N)
                        FAC=UN
                        IF (FVDATA(I)%IFVTRI(4,NN).NE.0) THEN
                           IDP=FVDATA(I)%IDPOLH(J)
                           RBUF(9*NNTR+NN)=IDP-(IDP/8)*8+1
                        ELSE
                           RBUF(9*NNTR+NN)=-1
                           FAC=UNDEMI
                        ENDIF
                        RBUF(NN)=RBUF(NN)+FAC*FVDATA(I)%MPOLH(J)
                        RBUF(NNTR+NN)=RBUF(NNTR+NN)
     .                                +FAC*FVDATA(I)%PPOLH(J)
                        IF (FVDATA(I)%MPOLH(J).GT.ZERO) THEN
                           RBUF(2*NNTR+NN)=RBUF(2*NNTR+NN)
     .                                    +FAC*FVDATA(I)%QPOLH(1,J)/
     .                                         FVDATA(I)%MPOLH(J)
                           RBUF(3*NNTR+NN)=RBUF(3*NNTR+NN)
     .                                    +FAC*FVDATA(I)%QPOLH(2,J)/
     .                                         FVDATA(I)%MPOLH(J)
                           RBUF(4*NNTR+NN)=RBUF(4*NNTR+NN)
     .                                    +FAC*FVDATA(I)%QPOLH(3,J)/
     .                                         FVDATA(I)%MPOLH(J)
                           RBUF(5*NNTR+NN)=RBUF(5*NNTR+NN)
     .                                    +FAC*FVDATA(I)%EPOLH(J)/
     .                                         FVDATA(I)%MPOLH(J)
                        ENDIF
                        RBUF(6*NNTR+NN)=RBUF(6*NNTR+NN)
     .                                 +FAC*FVDATA(I)%RPOLH(J)
                        RBUF(7*NNTR+NN)=RBUF(7*NNTR+NN)+FAC*SSP
                        RBUF(8*NNTR+NN)=RBUF(8*NNTR+NN)+FAC*GAMA
                     ENDDO
                  ENDDO
               ENDDO
               ITAG=MSGOFF2
               CALL MPI_SEND(RBUF, LEN, REAL, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD, IERR)
C
               DEALLOCATE(RBUF)        
            ENDIF
         ENDIF
      ENDDO      
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_AVEC                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_AVEC()
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I, PMASTER, NNS_ANIM, NNTR, J, K, KK, L, LL, N1, N2, N3,
     .        ITAG, LEN, MSGOFF, STAT(MPI_STATUS_SIZE), IERR,MSGOFF2
      my_real
     .        VVT(3)
      REAL R4
C
      INTEGER, DIMENSION(:), ALLOCATABLE :: NPTR, NPN
      my_real
     .       , DIMENSION(:,:), ALLOCATABLE :: VTR, VV
C
      DATA MSGOFF/7048/
      DATA MSGOFF2/7049/
C
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               NNS_ANIM=FVDATA(I)%NNS_ANIM
               NNTR=FVDATA(I)%NNTR
               ALLOCATE(VTR(3,NNTR), VV(3,NNS_ANIM), NPTR(NNTR),
     .                  NPN(NNS_ANIM))
C
               DO J=1,NNTR
                  NPTR(J)=0
                  VTR(1,J)=ZERO
                  VTR(2,J)=ZERO
                  VTR(3,J)=ZERO
               ENDDO
               DO J=1,NNS_ANIM
                  NPN(J)=0
                  VV(1,J)=ZERO
                  VV(2,J)=ZERO
                  VV(3,J)=ZERO
               ENDDO
               DO J=1,FVDATA(I)%NPOLH
                  IF (FVDATA(I)%MPOLH(J).EQ.ZERO) CYCLE
                  DO K=FVDATA(I)%IFVPADR(J),FVDATA(I)%IFVPADR(J+1)-1
                     KK=FVDATA(I)%IFVPOLH(K)
                     DO L=FVDATA(I)%IFVTADR(KK),
     .                    FVDATA(I)%IFVTADR(KK+1)-1
                        LL=FVDATA(I)%IFVPOLY(L)
                        NPTR(LL)=NPTR(LL)+1
                        VTR(1,LL)=VTR(1,LL)+FVDATA(I)%QPOLH(1,J)/
     .                                      FVDATA(I)%MPOLH(J)    
                        VTR(2,LL)=VTR(2,LL)+FVDATA(I)%QPOLH(2,J)/
     .                                      FVDATA(I)%MPOLH(J)    
                        VTR(3,LL)=VTR(3,LL)+FVDATA(I)%QPOLH(3,J)/
     .                                      FVDATA(I)%MPOLH(J)
                     ENDDO
                  ENDDO
               ENDDO
               DO J=1,NNTR
                  N1=FVDATA(I)%IFVTRI_ANIM(1,J)  
                  N2=FVDATA(I)%IFVTRI_ANIM(2,J)  
                  N3=FVDATA(I)%IFVTRI_ANIM(3,J)
                  NPN(N1)=NPN(N1)+1
                  NPN(N2)=NPN(N2)+1
                  NPN(N3)=NPN(N3)+1
                  IF (NPTR(J).NE.0) THEN
                     VVT(1)=VTR(1,J)/NPTR(J)
                     VVT(2)=VTR(2,J)/NPTR(J)
                     VVT(3)=VTR(3,J)/NPTR(J)
                  ELSE
                     VVT(1)=ZERO
                     VVT(2)=ZERO
                     VVT(3)=ZERO
                  ENDIF
                  VV(1,N1)=VV(1,N1)+VVT(1)
                  VV(2,N1)=VV(2,N1)+VVT(2)  
                  VV(3,N1)=VV(3,N1)+VVT(3)  
                  VV(1,N2)=VV(1,N2)+VVT(1)  
                  VV(2,N2)=VV(2,N2)+VVT(2)  
                  VV(3,N2)=VV(3,N2)+VVT(3)  
                  VV(1,N3)=VV(1,N3)+VVT(1)  
                  VV(2,N3)=VV(2,N3)+VVT(2)  
                  VV(3,N3)=VV(3,N3)+VVT(3)
               ENDDO
C
               DO J=1,NNS_ANIM
                  R4 = VV(1,J)/NPN(J)
                  CALL WRITE_R_C(R4,1)
                  R4 = VV(2,J)/NPN(J)
                  CALL WRITE_R_C(R4,1)
                  R4 = VV(3,J)/NPN(J)
                  CALL WRITE_R_C(R4,1)
               ENDDO
C
               DEALLOCATE(VTR, VV, NPTR, NPN)
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NNS_ANIM, 1, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               ALLOCATE(VV(3,NNS_ANIM))
               ITAG=MSGOFF2
               LEN=3*NNS_ANIM
               CALL MPI_RECV(VV, LEN, REAL, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               DO J=1,NNS_ANIM
                  R4 = VV(1,J)
                  CALL WRITE_R_C(R4,1)
                  R4 = VV(2,J)
                  CALL WRITE_R_C(R4,1)
                  R4 = VV(3,J)
                  CALL WRITE_R_C(R4,1)
               ENDDO
C
               DEALLOCATE(VV)
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               NNS_ANIM=FVDATA(I)%NNS_ANIM
               ITAG=MSGOFF
               CALL MPI_SEND(NNS_ANIM, 1, MPI_INTEGER, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD, IERR)
C
               NNTR=FVDATA(I)%NNTR
               ALLOCATE(VTR(3,NNTR), VV(3,NNS_ANIM), NPTR(NNTR),
     .                  NPN(NNS_ANIM))
C
               DO J=1,NNTR
                  NPTR(J)=0
                  VTR(1,J)=ZERO
                  VTR(2,J)=ZERO
                  VTR(3,J)=ZERO
               ENDDO
               DO J=1,NNS_ANIM
                  NPN(J)=0
                  VV(1,J)=ZERO
                  VV(2,J)=ZERO
                  VV(3,J)=ZERO
               ENDDO
               DO J=1,FVDATA(I)%NPOLH
                  IF (FVDATA(I)%MPOLH(J).EQ.ZERO) CYCLE
                  DO K=FVDATA(I)%IFVPADR(J),FVDATA(I)%IFVPADR(J+1)-1
                     KK=FVDATA(I)%IFVPOLH(K)
                     DO L=FVDATA(I)%IFVTADR(KK),
     .                    FVDATA(I)%IFVTADR(KK+1)-1
                        LL=FVDATA(I)%IFVPOLY(L)
                        NPTR(LL)=NPTR(LL)+1
                        VTR(1,LL)=VTR(1,LL)+FVDATA(I)%QPOLH(1,J)/
     .                                      FVDATA(I)%MPOLH(J)    
                        VTR(2,LL)=VTR(2,LL)+FVDATA(I)%QPOLH(2,J)/
     .                                      FVDATA(I)%MPOLH(J)    
                        VTR(3,LL)=VTR(3,LL)+FVDATA(I)%QPOLH(3,J)/
     .                                      FVDATA(I)%MPOLH(J)
                     ENDDO
                  ENDDO
               ENDDO
               DO J=1,NNTR
                  N1=FVDATA(I)%IFVTRI_ANIM(1,J)  
                  N2=FVDATA(I)%IFVTRI_ANIM(2,J)  
                  N3=FVDATA(I)%IFVTRI_ANIM(3,J)
                  NPN(N1)=NPN(N1)+1
                  NPN(N2)=NPN(N2)+1
                  NPN(N3)=NPN(N3)+1
                  IF (NPTR(J).NE.0) THEN
                     VVT(1)=VTR(1,J)/NPTR(J)
                     VVT(2)=VTR(2,J)/NPTR(J)
                     VVT(3)=VTR(3,J)/NPTR(J)
                  ELSE
                     VVT(1)=ZERO
                     VVT(2)=ZERO
                     VVT(3)=ZERO
                  ENDIF
                  VV(1,N1)=VV(1,N1)+VVT(1)
                  VV(2,N1)=VV(2,N1)+VVT(2)  
                  VV(3,N1)=VV(3,N1)+VVT(3)  
                  VV(1,N2)=VV(1,N2)+VVT(1)  
                  VV(2,N2)=VV(2,N2)+VVT(2)  
                  VV(3,N2)=VV(3,N2)+VVT(3)  
                  VV(1,N3)=VV(1,N3)+VVT(1)  
                  VV(2,N3)=VV(2,N3)+VVT(2)  
                  VV(3,N3)=VV(3,N3)+VVT(3)
               ENDDO
C
               DO J=1,NNS_ANIM
                  VV(1,J)=VV(1,J)/NPN(J)
                  VV(2,J)=VV(2,J)/NPN(J)
                  VV(3,J)=VV(3,J)/NPN(J)
               ENDDO
               ITAG=MSGOFF2
               LEN=3*NNS_ANIM
               CALL MPI_SEND(VV, LEN, REAL, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD,  IERR)
C
               DEALLOCATE(VTR, VV, NPTR, NPN)
            ENDIF
         ENDIF
      ENDDO  
C
      IF (ISPMD.EQ.0) THEN
         R4=ZERO
         DO I=1,3
            CALL WRITE_R_C(R4,1)
            CALL WRITE_R_C(R4,1)
            CALL WRITE_R_C(R4,1)
         ENDDO
      ENDIF
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_ANUM                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_ANUM(FVOFF, IDMAX, NFVNOD)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER FVOFF(2,*), IDMAX, NFVNOD
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I, PMASTER, J, JJ, ITAG, MSGOFF, STAT(MPI_STATUS_SIZE),
     .        IERR, NNS_ANIM
C-----------------------------------------------
      DATA MSGOFF/7050/
C-----------------------------------------------
C
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               DO J=1,FVDATA(I)%NNS_ANIM
                  JJ=FVOFF(2,I)+J
                  CALL WRITE_I_C(JJ,1)
               ENDDO
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NNS_ANIM, 1, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               DO J=1,NNS_ANIM
                  JJ=FVOFF(2,I)+J
                  CALL WRITE_I_C(JJ,1)
               ENDDO
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_SEND(FVDATA(I)%NNS_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD,
     .                       IERR)
            ENDIF
         ENDIF
      ENDDO
C
      IF (ISPMD.EQ.0) THEN
         CALL WRITE_I_C(IDMAX+NFVNOD+1,1)
         CALL WRITE_I_C(IDMAX+NFVNOD+2,1)
         CALL WRITE_I_C(IDMAX+NFVNOD+3,1)
      ENDIF     
C
#endif
      RETURN
      END      
Chd|====================================================================
Chd|  SPMD_FVB_ASUB1                priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_ASUB1(II, FVPBUF)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER II, FVPBUF(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I, PMASTER, J, ITAG, MSGOFF, STAT(MPI_STATUS_SIZE),
     .        IERR, NPOLH_ANIM, IADP
C-----------------------------------------------
      DATA MSGOFF /7051/
C-----------------------------------------------
C
      IADP=0
      DO I=1,NFVBAG
         II=II+1
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.EQ.PMASTER-1) THEN
               DO J=1,FVDATA(I)%NPOLH_ANIM
                  FVPBUF(IADP+J)=II-1
               ENDDO
               IADP=IADP+FVDATA(I)%NPOLH_ANIM
            ELSE
               ITAG=MSGOFF
               CALL MPI_RECV(NPOLH_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(PMASTER), ITAG, MPI_COMM_WORLD,
     .                       STAT, IERR)
               DO J=1,NPOLH_ANIM
                  FVPBUF(IADP+J)=II-1
               ENDDO
               IADP=IADP+NPOLH_ANIM
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_SEND(FVDATA(I)%NPOLH_ANIM, 1, MPI_INTEGER,
     .                       IT_SPMD(1), ITAG, MPI_COMM_WORLD,
     .                       IERR)
            ENDIF
         ENDIF
      ENDDO
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_ASUB2                priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_ASUB2()
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I, PMASTER, J, ITAG, TAB(2), STAT(MPI_STATUS_SIZE), IERR,
     .        ID, NPOLH_ANIM, MSGOFF
C-----------------------------------------------
      DATA MSGOFF /7052/
C-----------------------------------------------
C
      DO I=1,NFVBAG
         PMASTER=FVSPMD(I)%PMASTER
         IF (ISPMD.EQ.0) THEN
            IF (ISPMD.NE.PMASTER-1) THEN
               ITAG=MSGOFF
               CALL MPI_RECV(TAB, 2, MPI_INTEGER, IT_SPMD(PMASTER),
     .                       ITAG, MPI_COMM_WORLD, STAT, IERR)
C
               FVDATA(I)%ID=TAB(1)
               FVDATA(I)%NPOLH_ANIM=TAB(2)
            ENDIF
         ELSE
            IF (ISPMD.EQ.PMASTER-1) THEN
               TAB(1)=FVDATA(I)%ID
               TAB(2)=FVDATA(I)%NPOLH_ANIM
C
               ITAG=MSGOFF
               CALL MPI_SEND(TAB, 2, MPI_INTEGER, IT_SPMD(1),
     .                       ITAG, MPI_COMM_WORLD,  IERR)
            ENDIF
         ENDIF
      ENDDO  
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_AMAX                 priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        DELNUMBC                      src/anim/delnumbc.F           
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_FVB_AMAX(IDCMAX, IDCMAXL)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER IDCMAX, IDCMAXL
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER I, ITAG, MSGOFF, IDCMAXP(NSPMD-1), REQ(NSPMD-1),
     .        STAT(MPI_STATUS_SIZE,NSPMD-1), IERR
C-----------------------------------------------
      DATA MSGOFF/7053/
C-----------------------------------------------
C
      IF (ISPMD.EQ.0) THEN
         DO I=1,NSPMD-1
            ITAG=MSGOFF
            CALL MPI_IRECV(IDCMAXP(I), 1, MPI_INTEGER, IT_SPMD(I+1),
     .                     ITAG, MPI_COMM_WORLD, REQ(I), IERR)
         ENDDO
         CALL MPI_WAITALL(NSPMD-1, REQ, STAT, IERR)
C         
         IDCMAX=IDCMAXL
         DO I=1,NSPMD-1
            IDCMAX=MAX(IDCMAX,IDCMAXP(I))
         ENDDO
      ELSE
         ITAG=MSGOFF
         CALL MPI_ISEND(IDCMAXL, 1, MPI_INTEGER, IT_SPMD(1),
     .                  ITAG, MPI_COMM_WORLD, REQ, IERR)
         CALL MPI_WAIT(REQ, STAT, IERR)
      ENDIF
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_FVB_SCAT_NUM_NODA        priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        ALEVFLU                       src/anim/genani.F             
Chd|        ANIMBALE                      src/anim/genani.F             
Chd|-- calls ---------------
Chd|        FVBAG_MOD                     share/modules/fvbag_mod.F     
Chd|====================================================================
      SUBROUTINE SPMD_FVB_SCAT_NUM_NODA(IFV,VECTOR,LEN)
C-----------------------------------------------
C   M o d u l e s
C-----------------------------------------------
      USE FVBAG_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      my_real
     *   VECTOR(*)
      INTEGER LEN,IFV
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER IERR,PMASTER
C-----------------------------------------------

      PMASTER=FVSPMD(IFV)%PMASTER
      CALL MPI_BCAST(VECTOR, LEN, REAL, PMASTER-1,
     .               MPI_COMM_WORLD, IERR)

#endif MPI
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_ANIM_PLY_INIT            priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        RESOL_INIT                    src/resol/resol_init.F        
Chd|-- calls ---------------
Chd|        PLYXFEM_MOD                   share/modules/plyxfem_mod.F   
Chd|====================================================================
      SUBROUTINE SPMD_ANIM_PLY_INIT()
C-----------------------------------------------
C   M o d u l e s
C-----------------------------------------------
      USE PLYXFEM_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "param_c.inc"
#include      "scr05_c.inc"
#include      "scr14_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER, DIMENSION(:),ALLOCATABLE :: PLYNODTAG,SENDBUF,RECBUF
      INTEGER MAXSENDSZ,RECSZ,PLYSZ
      INTEGER I,J,P,ND, ITAG, IDCMAXP(NSPMD-1), REQ(NSPMD-1),NODCOUNT
      INTEGER MSGOFF,MSGOFF2,STAT(MPI_STATUS_SIZE,NSPMD-1), IERR
C-----------------------------------------------
      DATA MSGOFF/7054/
C-----------------------------------------------
C
C Allocate Global PLY Structure
C
      IF (ISPMD==0)THEN
        ALLOCATE (PLYIADNOD(NPLYMAX,NSPMD))
        PLYIADNOD = 0
      ELSE
         ALLOCATE (PLYIADNOD(1,1))
      ENDIF
      PLYIADNOD = 0


C Need to rebuild a global PLYNOD Structure on processor 0 to have
C a conversion array from Global Node ID to Internal PLYNOD ID

      DO I=1,NPLYMAX
        IF (ISPMD==0)THEN
C PROC 0, RECEIVE NODES NUM for each ply
           DO P=2,NSPMD
              ITAG=MSGOFF
              CALL MPI_RECV(RECSZ,1, MPI_INTEGER, IT_SPMD(P),
     .                      ITAG, MPI_COMM_WORLD, STAT, IERR)
              PLYIADNOD(I,P) = RECSZ
           ENDDO
        ELSE
           ITAG=MSGOFF
           CALL MPI_SEND(PLYNOD(I)%PLYNUMNODS,1,MPI_INTEGER,IT_SPMD(1),
     .                   ITAG,MPI_COMM_WORLD,IERR)
        ENDIF
      ENDDO

C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_ANIM_PLY_XYZNOD          priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        XYZNOD_PLY                    src/anim/xyznod_ply.F         
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|        PLYXFEM_MOD                   share/modules/plyxfem_mod.F   
Chd|====================================================================
      SUBROUTINE SPMD_ANIM_PLY_XYZNOD( NODGLOB,IPLY, IDPLY,
     *                                 NOD_PXFEM, X, ZI_PLY,EMPSIZPL )
C-----------------------------------------------
C   M o d u l e s
C-----------------------------------------------
      USE PLYXFEM_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "param_c.inc"
#include      "scr05_c.inc"
#include      "scr14_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NODGLOB(*),NOD_PXFEM(*),EMPSIZPL
      INTEGER IPLY,IDPLY
      my_real
     .   X(3,*),ZI_PLY(NPLYXFE,*)
      REAL R4
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGOFF2,STAT(MPI_STATUS_SIZE,NSPMD-1), IERR
C-----------------------------------------------
      DATA MSGOFF/7055/
      DATA MSGOFF2/7056/
C-----------------------------------------------
      INTEGER I,N,II,ND,EMPL,P,ITAG
      INTEGER PLYSIZ
      my_real
     .   VN,VAL,NORM
C
      REAL , DIMENSION(:,:), ALLOCATABLE :: WRTBUF
      my_real
     * , DIMENSION(:,:), ALLOCATABLE :: FSENDBUF,FRECBUF
      INTEGER, DIMENSION(:), ALLOCATABLE :: ISENDBUF,IRECBUF
C-----------------------------------------------

       II = IDPLY
C

      IF (ISPMD ==0) THEN
        PLYSIZ  = PLYNOD (IPLY)%PLYNUMNODS
        ALLOCATE(WRTBUF(3,PLYSIZG(IPLY)))

C Les plynods du proc 0
        DO ND=1,PLYSIZ
             I = PLYNOD(IPLY)%NODES(ND)
             N = NOD_PXFEM(I)
             NORM = SQRT(VN_NOD(1,N)**2+VN_NOD(2,N)**2+VN_NOD(3,N)**2)
             NORM = UN/MAX(EM20,NORM)
             EMPL = PLYNOD(IPLY)%PLYNODID(ND)-EMPSIZPL
             
             VN = VN_NOD(1,N)*NORM
             VAL = X(1,I)+ZI_PLY(N,IPLY)*VN + PLY(IPLY)%U(1,N)
             WRTBUF(1,EMPL)= VAL

             VN = VN_NOD(2,N)*NORM
             VAL = X(2,I)+ZI_PLY(N,IPLY)*VN + PLY(IPLY)%U(2,N)
             WRTBUF(2,EMPL)= VAL

             VN = VN_NOD(3,N)*NORM
             VAL = X(3,I)+ZI_PLY(N,IPLY)*VN + PLY(IPLY)%U(3,N)
             WRTBUF(3,EMPL)= VAL
        END DO
C Les plynods des autres procs
           DO P=2,NSPMD
             IF (PLYIADNOD(IPLY,P)>0)THEN
              ALLOCATE(IRECBUF(PLYIADNOD(IPLY,P)))
              ALLOCATE(FRECBUF(3,PLYIADNOD(IPLY,P)))
              ITAG=MSGOFF
              CALL MPI_RECV(IRECBUF,PLYIADNOD(IPLY,P), MPI_INTEGER,
     .                      IT_SPMD(P),ITAG, MPI_COMM_WORLD, STAT, IERR)
              ITAG=MSGOFF2
              CALL MPI_RECV(FRECBUF,PLYIADNOD(IPLY,P)*3, REAL,
     .                      IT_SPMD(P),ITAG, MPI_COMM_WORLD, STAT, IERR)
              DO I=1,PLYIADNOD(IPLY,P)
                 EMPL = IRECBUF(I)-EMPSIZPL
                 WRTBUF(1,EMPL)=FRECBUF(1,I)
                 WRTBUF(2,EMPL)=FRECBUF(2,I)
                 WRTBUF(3,EMPL)=FRECBUF(3,I)
              ENDDO
              DEALLOCATE(IRECBUF,FRECBUF)
            ENDIF
           ENDDO

           CALL WRITE_R_C(WRTBUF,3*PLYSIZG(IPLY))
           DEALLOCATE(WRTBUF)
           EMPSIZPL=EMPSIZPL+PLYSIZG(IPLY)
      ELSE
        PLYSIZ = PLYNOD(IPLY)%PLYNUMNODS
        ALLOCATE (FSENDBUF(3,PLYSIZ))
        ALLOCATE (ISENDBUF(PLYSIZ))
        IF (PLYSIZ > 0) THEN
         DO ND=1,PLYSIZ
           I = PLYNOD(IPLY)%NODES(ND)
           N = NOD_PXFEM(I)
           NORM = SQRT(VN_NOD(1,N)**2+VN_NOD(2,N)**2+VN_NOD(3,N)**2)
           NORM = UN/MAX(EM20,NORM)
           VN = VN_NOD(1,N)*NORM
           FSENDBUF(1,ND) = X(1,I)+ZI_PLY(N,IPLY)*VN + PLY(IPLY)%U(1,N)
           VN = VN_NOD(2,N)*NORM
           FSENDBUF(2,ND) = X(2,I)+ZI_PLY(N,IPLY)*VN + PLY(IPLY)%U(2,N)
           VN = VN_NOD(3,N)*NORM
           FSENDBUF(3,ND) = X(3,I)+ZI_PLY(N,IPLY)*VN + PLY(IPLY)%U(3,N)
           ISENDBUF(ND) = PLYNOD(IPLY)%PLYNODID(ND)
         END DO
         ITAG=MSGOFF
         CALL MPI_SEND(ISENDBUF,PLYSIZ,MPI_INTEGER,IT_SPMD(1),
     .                   ITAG,MPI_COMM_WORLD,IERR)

         ITAG=MSGOFF2
         CALL MPI_SEND(FSENDBUF,PLYSIZ*3,REAL,IT_SPMD(1),
     .                   ITAG,MPI_COMM_WORLD,IERR)
C
         DEALLOCATE(ISENDBUF,FSENDBUF)
        ENDIF
      ENDIF
C-----------------------------------------------

#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_IGET_PARTN_PLY           priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        DELNUMBC_PLY                  src/anim/delnumbc_ply.F       
Chd|        PARSOR_PLY                    src/anim/parsor_ply.F         
Chd|-- calls ---------------
Chd|        WRITE_C_C                     src/sortie/sortie_c.c         
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|        PLYXFEM_MOD                   share/modules/plyxfem_mod.F   
Chd|====================================================================
      SUBROUTINE SPMD_IGET_PARTN_PLY(SIZE,NBF_L,NP,NBPART,IADG,
     *           SRBUF,IFLAG,IDPLY)
C-----------------------------------------------
C   M o d u l e s
C-----------------------------------------------
      USE PLYXFEM_MOD
C gather sur p0 du tableau wa en fonction des parts (IADG)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------

#ifdef MPI
#include "mpif.h"
#endif

C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NBF_L, NP(*),IADG(NSPMD,*),SIZE
      INTEGER  NBPART, IFLAG,SRBUF,IDPLY
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGTYP,INFO,IDEB,K,N,NB_TMP,LEN,IADP(NSPMD),
     .        I,EMPL,IPLY

      INTEGER, DIMENSION(:),ALLOCATABLE :: RBUF,RBUF2,NPT
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR
      INTEGER  GET_PLY_NOD
      EXTERNAL GET_PLY_NOD
      DATA MSGOFF/7057/
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      ALLOCATE(RBUF(SRBUF))
      ALLOCATE(RBUF2(SRBUF))
      ALLOCATE(NPT(NBF_L))

      IF (ISPMD.NE.0) THEN
        MSGTYP=MSGOFF

        CALL MPI_SEND(NP,NBF_L,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .                MPI_COMM_WORLD,ierror)

      ELSE
        DO K=1,NBF_L
           RBUF(K) = NP(K)
        ENDDO
        IDEB = NBF_L +  1
        IADP(1) = 1
C
      DO K=2,NSPMD
        IADP(K) = IDEB
        MSGTYP=MSGOFF

         CALL MPI_PROBE(IT_SPMD(K),MSGTYP,
     .                   MPI_COMM_WORLD,STATUS,ierror)
         CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,NB_TMP,ierror)

         CALL MPI_RECV(RBUF(IDEB),NB_TMP,MPI_INTEGER,IT_SPMD(K),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

        IDEB = IDEB + NB_TMP
        END DO
C
        DO N = 1, NBPART
          IPLY=INDX_PLY(N)
          DO K = 1, NSPMD
            IF (N.GT.1) THEN
              LEN = (IADG(K,N) - IADG(K,N-1))*SIZE
            ELSE
              LEN = IADG(K,N)*SIZE
            ENDIF
            IF (IFLAG.EQ.1) THEN
              DO I=IADP(K), IADP(K)+LEN-1
                RBUF(I) = RBUF(I)+IDPLY
              ENDDO
              CALL WRITE_I_C(RBUF(IADP(K)),LEN)
            ELSEIF(IFLAG.EQ.2) THEN
              CALL WRITE_C_C(RBUF(IADP(K)),LEN)
            ENDIF
            IADP(K) = IADP(K) + LEN
          ENDDO
        ENDDO
      ENDIF
C
      DEALLOCATE(RBUF)
      DEALLOCATE(RBUF2)
      DEALLOCATE(NPT)
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_ANIM_PLY_XYZNOR          priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        XYZNOR_PLY                    src/anim/xyznor_ply.F         
Chd|-- calls ---------------
Chd|        WRITE_S_C                     src/sortie/sortie_c.c         
Chd|        PLYXFEM_MOD                   share/modules/plyxfem_mod.F   
Chd|====================================================================
      SUBROUTINE SPMD_ANIM_PLY_XYZNOR( NODGLOB,IPLY,XNORM,EMPSIZPL)
C-----------------------------------------------
C   M o d u l e s
C-----------------------------------------------
      USE PLYXFEM_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "param_c.inc"
#include      "scr05_c.inc"
#include      "scr14_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NODGLOB(*)
      INTEGER IPLY,IDPLY,EMPSIZPL
      my_real
     .   XNORM(3,*)
      REAL R4
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGOFF2,STAT(MPI_STATUS_SIZE,NSPMD-1), IERR
      INTEGER I,N,ND,EMPL,P,ITAG,INORM(3),K,IXNN

      INTEGER PLYSIZ
      my_real
     .   S3000,S
C
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: WRTBUF
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: FSENDBUF,FRECBUF
      INTEGER, DIMENSION(:), ALLOCATABLE :: ISENDBUF,IRECBUF
C-----------------------------------------------
      DATA MSGOFF/7058/
      DATA MSGOFF2/7059/
C-----------------------------------------------
      S3000 = TROIS1000
      IXNN = S3000
      IF(FMT_ANI.EQ.4)IXNN=0
C
      IF (ISPMD ==0) THEN
        PLYSIZ  = PLYNOD (IPLY)%PLYNUMNODS
        ALLOCATE(WRTBUF(3,PLYSIZG(IPLY)))

C Les plynods du proc 0
        DO ND=1,PLYSIZ
             I = PLYNOD(IPLY)%NODES(ND)
             EMPL =  PLYNOD(IPLY)%PLYNODID(ND)-EMPSIZPL

             S = SQRT(XNORM(1,I)**2 + XNORM(2,I)**2 + XNORM(3,I)**2)
             IF(S.NE.ZERO)THEN
                S = S3000 / S
                INORM(1) = XNORM(1,I) * S
                INORM(2) = XNORM(2,I) * S
                INORM(3) = XNORM(3,I) * S
             ELSE
                INORM(1) = 0
                INORM(2) = 0
                INORM(3) = IXNN
             END IF

             WRTBUF(1,EMPL)= INORM(1)
             WRTBUF(2,EMPL)= INORM(2)
             WRTBUF(3,EMPL)= INORM(3)
        END DO
C Les plynods des autres procs
           DO P=2,NSPMD
              ALLOCATE(IRECBUF(PLYIADNOD(IPLY,P)))
              ALLOCATE(FRECBUF(3,PLYIADNOD(IPLY,P)))

              ITAG=MSGOFF

              CALL MPI_RECV(IRECBUF,PLYIADNOD(IPLY,P), MPI_INTEGER,
     .                      IT_SPMD(P),ITAG, MPI_COMM_WORLD, STAT, IERR)

              ITAG=MSGOFF2
              CALL MPI_RECV(FRECBUF,PLYIADNOD(IPLY,P)*3, MPI_INTEGER,
     .                      IT_SPMD(P),ITAG, MPI_COMM_WORLD, STAT, IERR)

              DO I=1,PLYIADNOD(IPLY,P)
                 EMPL = IRECBUF(I)-EMPSIZPL
                 WRTBUF(1,EMPL)=FRECBUF(1,I)
                 WRTBUF(2,EMPL)=FRECBUF(2,I)
                 WRTBUF(3,EMPL)=FRECBUF(3,I)
              ENDDO
              DEALLOCATE(IRECBUF,FRECBUF)
           ENDDO

           CALL WRITE_S_C(WRTBUF,3*PLYSIZG(IPLY))
           DEALLOCATE(WRTBUF)
           EMPSIZPL=EMPSIZPL+PLYSIZG(IPLY)

      ELSE
        PLYSIZ = PLYNOD(IPLY)%PLYNUMNODS
        ALLOCATE (FSENDBUF(3,PLYSIZ))
        ALLOCATE (ISENDBUF(PLYSIZ))

        DO ND=1,PLYSIZ
             I = PLYNOD(IPLY)%NODES(ND)

             S = SQRT(XNORM(1,I)**2 + XNORM(2,I)**2 + XNORM(3,I)**2)
             IF(S.NE.ZERO)THEN
                S = S3000 / S
                INORM(1) = XNORM(1,I) * S
                INORM(2) = XNORM(2,I) * S
                INORM(3) = XNORM(3,I) * S
             ELSE
                INORM(1) = 0
                INORM(2) = 0
                INORM(3) = IXNN
             END IF

           FSENDBUF(1,ND) = INORM(1)
           FSENDBUF(2,ND) = INORM(2)
           FSENDBUF(3,ND) = INORM(3)

           ISENDBUF(ND) =  PLYNOD(IPLY)%PLYNODID(ND)
        END DO

        ITAG=MSGOFF
        CALL MPI_SEND(ISENDBUF,PLYSIZ,MPI_INTEGER,IT_SPMD(1),
     .                   ITAG,MPI_COMM_WORLD,IERR)

        ITAG=MSGOFF2
        CALL MPI_SEND(FSENDBUF,PLYSIZ*3,MPI_INTEGER,IT_SPMD(1),
     .                   ITAG,MPI_COMM_WORLD,IERR)
C
        DEALLOCATE(ISENDBUF,FSENDBUF)
      ENDIF

#endif
      RETURN
      END
C-----------------------------------------------
Chd|====================================================================
Chd|  SPMD_ANIM_PLY_VELVEC          priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        VELVEC                        src/anim/velvec.F             
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|        PLYXFEM_MOD                   share/modules/plyxfem_mod.F   
Chd|====================================================================
      SUBROUTINE SPMD_ANIM_PLY_VELVEC( NODGLOB,IPLY,
     *                                 NOD_PXFEM, IFUNC,EMPSIZPL)
C-----------------------------------------------
C   M o d u l e s
C-----------------------------------------------
      USE PLYXFEM_MOD
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "param_c.inc"
#include      "scr05_c.inc"
#include      "scr14_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER NODGLOB(*),NOD_PXFEM(*)
      INTEGER IPLY,IFUNC,EMPSIZPL
      REAL R4
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGOFF2,STAT(MPI_STATUS_SIZE,NSPMD-1), IERR
      INTEGER I,N,ND,EMPL,P,ITAG,EMP
      INTEGER PLYSIZ
      my_real
     .   VN,VAL
C
      REAL , DIMENSION(:,:), ALLOCATABLE :: WRTBUF
      my_real
     * , DIMENSION(:,:), ALLOCATABLE :: FSENDBUF,FRECBUF
      INTEGER, DIMENSION(:), ALLOCATABLE :: ISENDBUF,IRECBUF
C-----------------------------------------------
      DATA MSGOFF/7060/
      DATA MSGOFF2/7061/
C-----------------------------------------------

C
      IF (ISPMD ==0) THEN
        PLYSIZ  = PLYNOD (IPLY)%PLYNUMNODS
        ALLOCATE(WRTBUF(3,PLYSIZG(IPLY)))

C Les plynods du proc 0
        DO ND=1,PLYSIZ
             I = PLYNOD(IPLY)%NODES(ND)
             N = NOD_PXFEM(I)
             EMPL = PLYNOD(IPLY)%PLYNODID(ND)-EMPSIZPL

             IF (IFUNC==1)THEN
                WRTBUF(1,EMPL)= PLY(IPLY)%V(1,N)
                WRTBUF(2,EMPL)= PLY(IPLY)%V(2,N)
                WRTBUF(3,EMPL)= PLY(IPLY)%V(3,N)

             ELSEIF (IFUNC==2)THEN
                WRTBUF(1,EMPL)= PLY(IPLY)%U(1,N)
                WRTBUF(2,EMPL)= PLY(IPLY)%U(2,N)
                WRTBUF(3,EMPL)= PLY(IPLY)%U(3,N)

             ELSEIF (IFUNC==3)THEN
                WRTBUF(1,EMPL)= PLY(IPLY)%A(1,N)
                WRTBUF(2,EMPL)= PLY(IPLY)%A(2,N)
                WRTBUF(3,EMPL)= PLY(IPLY)%A(3,N)
             ELSE
                WRTBUF(1,EMPL)= ZERO
                WRTBUF(2,EMPL)= ZERO
                WRTBUF(3,EMPL)= ZERO
             ENDIF
        END DO
C Les plynods des autres procs
           DO P=2,NSPMD
             IF (PLYIADNOD(IPLY,P)>0)THEN
              ALLOCATE(IRECBUF(PLYIADNOD(IPLY,P)))
              ALLOCATE(FRECBUF(3,PLYIADNOD(IPLY,P)))
              ITAG=MSGOFF
              CALL MPI_RECV(IRECBUF,PLYIADNOD(IPLY,P), MPI_INTEGER,
     .                      IT_SPMD(P),ITAG, MPI_COMM_WORLD, STAT, IERR)
              ITAG=MSGOFF2
              CALL MPI_RECV(FRECBUF,PLYIADNOD(IPLY,P)*3, REAL,
     .                      IT_SPMD(P),ITAG, MPI_COMM_WORLD, STAT, IERR)

              DO I=1,PLYIADNOD(IPLY,P)
                 EMPL = IRECBUF(I)-EMPSIZPL
                 WRTBUF(1,EMPL)=FRECBUF(1,I)
                 WRTBUF(2,EMPL)=FRECBUF(2,I)
                 WRTBUF(3,EMPL)=FRECBUF(3,I)
              ENDDO
              DEALLOCATE(IRECBUF,FRECBUF)
            ENDIF
           ENDDO
           CALL WRITE_R_C(WRTBUF,3*PLYSIZG(IPLY))
           DEALLOCATE(WRTBUF)
           EMPSIZPL = EMPSIZPL + PLYSIZG(IPLY)
      ELSE
        PLYSIZ = PLYNOD(IPLY)%PLYNUMNODS
        ALLOCATE (FSENDBUF(3,PLYSIZ))
        ALLOCATE (ISENDBUF(PLYSIZ))
        IF (PLYSIZ > 0) THEN
         DO ND=1,PLYSIZ
           I = PLYNOD(IPLY)%NODES(ND)
           N = NOD_PXFEM(I)

           IF (IFUNC==1)THEN
              FSENDBUF(1,ND) = PLY(IPLY)%V(1,N)
              FSENDBUF(2,ND) = PLY(IPLY)%V(2,N)
              FSENDBUF(3,ND) = PLY(IPLY)%V(3,N)

           ELSEIF (IFUNC==2)THEN
              FSENDBUF(1,ND) = PLY(IPLY)%U(1,N)
              FSENDBUF(2,ND) = PLY(IPLY)%U(2,N)
              FSENDBUF(3,ND) = PLY(IPLY)%U(3,N)

           ELSEIF (IFUNC==3)THEN
              FSENDBUF(1,ND) = PLY(IPLY)%A(1,N)
              FSENDBUF(2,ND) = PLY(IPLY)%A(2,N)
              FSENDBUF(3,ND) = PLY(IPLY)%A(3,N)
           ELSE
              FSENDBUF(1,ND) = ZERO
              FSENDBUF(2,ND) = ZERO
              FSENDBUF(3,ND) = ZERO
           ENDIF

             ISENDBUF(ND) =  PLYNOD(IPLY)%PLYNODID(ND)
         END DO

         ITAG=MSGOFF
         CALL MPI_SEND(ISENDBUF,PLYSIZ,MPI_INTEGER,IT_SPMD(1),
     .                   ITAG,MPI_COMM_WORLD,IERR)

         ITAG=MSGOFF2
         CALL MPI_SEND(FSENDBUF,PLYSIZ*3,REAL,IT_SPMD(1),
     .                   ITAG,MPI_COMM_WORLD,IERR)
C
         DEALLOCATE(ISENDBUF,FSENDBUF)
        ENDIF
      ENDIF
C-----------------------------------------------
#endif
      RETURN
      END

Chd|====================================================================
Chd|  SPMD_GLOB_IMAX9               priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|        SMS_INI_KIN_1                 priv/sms/sms_init.F           
Chd|        SMS_INI_KIN_2                 priv/sms/sms_init.F           
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_GLOB_IMAX9(V,LEN)
C gather tableau V de taille LEN de type integer
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER LEN, V(LEN)
C-----------------------------------------------
C   L o c a l  V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER MSGOFF,MSGTYP,INFO,I,K,ATID,ATAG,ALEN,IERROR,
     .        VTMP(LEN),STATUS(MPI_STATUS_SIZE)
C-----------------------------------------------
C   S o u r c e  L i n e s
C-----------------------------------------------
      IF (LEN .GT. 0) THEN
        CALL MPI_REDUCE(V,VTMP,LEN,
     .                  MPI_INTEGER,MPI_MAX,IT_SPMD(1),
     .                  MPI_COMM_WORLD,IERROR)
      ENDIF
      IF (ISPMD.EQ.0) THEN
        DO I=1,LEN
          V(I) = VTMP(I)
        END DO
      ENDIF
C
#endif
      RETURN
      END
C
Chd|====================================================================
Chd|  SPMD_CRK_IDMAX                priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|====================================================================
      SUBROUTINE SPMD_CRK_IDMAX(IDMAX,ITAB)
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
C-----------------------------------------------------------------
C   M e s s a g e   P a s s i n g
C-----------------------------------------------
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER IDMAX,ITAB(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
#ifdef MPI
      INTEGER IDMAXL, I, ITAG, MSGOFF, IDMAXP(NSPMD-1), 
     .        REQ(NSPMD-1), IERR, STAT(MPI_STATUS_SIZE,NSPMD-1)
C-----------------------------------------------
      DATA MSGOFF/7063/
C-----------------------------------------------
      IDMAXL=0
      DO I=1,NUMNOD
         IDMAXL=MAX(IDMAXL,ITAB(I))
      ENDDO
      IF (ISPMD.EQ.0) THEN
         DO I=1,NSPMD-1
            ITAG=MSGOFF
            CALL MPI_IRECV(IDMAXP(I), 1, MPI_INTEGER, IT_SPMD(I+1),
     .                     ITAG, MPI_COMM_WORLD, REQ(I), IERR)
         ENDDO
         CALL MPI_WAITALL(NSPMD-1, REQ, STAT, IERR)
C
         IDMAX=IDMAXL
         DO I=1,NSPMD-1
            IDMAX=MAX(IDMAX,IDMAXP(I))
         ENDDO
      ELSE
         ITAG=MSGOFF
         CALL MPI_ISEND(IDMAXL, 1, MPI_INTEGER, IT_SPMD(1),
     .                  ITAG, MPI_COMM_WORLD, REQ, IERR)
         CALL MPI_WAIT(REQ, STAT, IERR)
      ENDIF
C
#endif
      RETURN
      END
Chd|====================================================================
Chd|  SPMD_WRT_CRK_XYZNOD           priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        XYZNOD_CRK                    src/anim/xyznod_crk.F         
Chd|-- calls ---------------
Chd|        WRITE_R_C                     src/sortie/sortie_c.c         
Chd|        CRACKXFEM_MOD                 share/modules/crackxfem_mod.F 
Chd|====================================================================
       SUBROUTINE SPMD_WRT_CRK_XYZNOD(ICRK,NUM,NODGLOBXFE)
C-----------------------------------------------
      USE CRACKXFEM_MOD        
C-----------------------------------------------
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
#include      "param_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       INTEGER ICRK,NUM,NODGLOBXFE(*)
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF,EMPL
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2,MSGTYP2,SIZ0,STEP
C
      REAL, DIMENSION(:,:), ALLOCATABLE :: BUFSR,XGLOB
      INTEGER, DIMENSION(:), ALLOCATABLE ::  IBUF
C-----------------------------------------------
      DATA MSGOFF/7064/
      DATA MSGOFF2/7065/
C-----------------------------------------------
       ALLOCATE(BUFSR(3,NCRKNODG))
       ALLOCATE(IBUF(NCRKNODG))
       ALLOCATE(XGLOB(3,NUM))
C-----------------------------------------------

       IF (ISPMD.NE.0) THEN
         SIZ = 0
         STEP = 0
         DO I=1,CRKNOD(ICRK)%CRKNUMNODS
           STEP = CRKNOD(ICRK)%CRKNUMNODS*(ICRK-1)
           SIZ = SIZ + 1
           IBUF(SIZ) = NODGLOBXFE(I+STEP)
           BUFSR(1,SIZ) = CRKAVX(ICRK)%XX(1,I)
           BUFSR(2,SIZ) = CRKAVX(ICRK)%XX(2,I)
           BUFSR(3,SIZ) = CRKAVX(ICRK)%XX(3,I)
         END DO
C
Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max
C
         MSGTYP = MSGOFF2 
         CALL MPI_SEND(IBUF,SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .                 MPI_COMM_WORLD,ierror)
Cow
         MSGTYP = MSGOFF
         CALL MPI_SEND(BUFSR,3*SIZ,MPI_REAL4,IT_SPMD(1),MSGTYP,
     .                 MPI_COMM_WORLD,ierror)
       ELSE
           STEP = 0
C
C proc 0
C
          DO I=1,CRKNOD(ICRK)%CRKNUMNODS
            STEP = CRKNOD(ICRK)%CRKNUMNODS*(ICRK-1)
            NG = NODGLOBXFE(I+STEP)
            XGLOB(1,NG) = CRKAVX(ICRK)%XX(1,I)
            XGLOB(2,NG) = CRKAVX(ICRK)%XX(2,I)
            XGLOB(3,NG) = CRKAVX(ICRK)%XX(3,I)
cc            CALL WRITE_R_C(XGLOB(1,NG),1)
cc            CALL WRITE_R_C(XGLOB(2,NG),1)
cc            CALL WRITE_R_C(XGLOB(3,NG),1)
          ENDDO
C------------
          DO I=2,NSPMD

Cow Reception du buffer entier des adresses NODGLOB
            MSGTYP = MSGOFF2
            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                     MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)
            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
c
Cow Reception du buffer flottant des adresses NODGLOB
c
            MSGTYP2 = MSGOFF
c
            CALL MPI_RECV(BUFSR,SIZ*3,MPI_REAL4,IT_SPMD(I),MSGTYP2,
     .                    MPI_COMM_WORLD,STATUS,ierror)
c
            NREC = SIZ 
c
            DO K = 1, NREC
              NG = IBUF(K)
              XGLOB(1,NG) = BUFSR(1,K)
              XGLOB(2,NG) = BUFSR(2,K)
              XGLOB(3,NG) = BUFSR(3,K)
cc              CALL WRITE_R_C(XGLOB(1,NG),1)
cc              CALL WRITE_R_C(XGLOB(2,NG),1)
cc              CALL WRITE_R_C(XGLOB(3,NG),1)
            ENDDO
          ENDDO
C
c          DO I=1,NUM
cc          DO I=1,NCRKNODG
cc           CALL WRITE_R_C(XGLOB(1,I),1)
cc           CALL WRITE_R_C(XGLOB(2,I),1)
cc           CALL WRITE_R_C(XGLOB(3,I),1)
cc         END DO
C
        DO I=1,NCRKNODG
          K=I+NCRKNODG*(ICRK-1)
          CALL WRITE_R_C(XGLOB(1,K),1)
          CALL WRITE_R_C(XGLOB(2,K),1)
          CALL WRITE_R_C(XGLOB(3,K),1)
        ENDDO
C
        END IF
C---
C-----------------------------------------------
       DEALLOCATE(BUFSR)
       DEALLOCATE(IBUF)
       DEALLOCATE(XGLOB)
C-----------------------------------------------
#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_WRT_CRK_XYZNOR           priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        XYZNOR_CRK                    src/anim/xyznor_crk.F         
Chd|-- calls ---------------
Chd|        WRITE_S_C                     src/sortie/sortie_c.c         
Chd|        CRACKXFEM_MOD                 share/modules/crackxfem_mod.F 
Chd|====================================================================
       SUBROUTINE SPMD_WRT_CRK_XYZNOR(ICRK,XNORM,NUM)
C-----------------------------------------------
      USE CRACKXFEM_MOD        
C-----------------------------------------------
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "scr14_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
#include      "param_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       INTEGER ICRK,NUM
      my_real
     .   XNORM(3,*)
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF,EMPL
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,MSGOFF2,SI,MSGTYP2,SIZ0
C
      INTEGER,DIMENSION(:,:),ALLOCATABLE ::  RNGLOB,IBUF
 
Cow Tableau utilise par proc 0
      my_real
     .   S3000,S,XN1,XN2,XN3,IXNN
C-----------------------------------------------         
      DATA MSGOFF/7066/
      DATA MSGOFF2/7067/
C-----------------------------------------------  
      ALLOCATE(IBUF(4,NCRKNODG))
      ALLOCATE(RNGLOB(3,NUM))
C-----------------------------------------------  

      S3000 = TROIS1000
      IXNN = S3000
      IF(FMT_ANI.EQ.4)IXNN=0
C---
       IF (ISPMD.NE.0) THEN

        SIZ = 0
        DO I=1,CRKNOD(ICRK)%CRKNUMNODS
           EMPL = CRKNOD(ICRK)%XFENODES(I)
C           S = SQRT(XNORM(1,I)**2 + XNORM(2,I)**2 + XNORM(3,I)**2)
           S = ZERO
           IF(S /= ZERO)THEN
c             S = S3000 / S
c               XN1 = XNORM(1,I) * S
c               XN2 = XNORM(2,I) * S
c               XN3 = XNORM(3,I) * S
           ELSE
             XN1 = 0
             XN2 = 0
             XN3 = IXNN
           END IF
           SIZ = SIZ + 1
           IBUF(1,SIZ) = CRKNOD(ICRK)%XFECRKNODID(I)
           IBUF(2,SIZ) = XN1
           IBUF(3,SIZ) = XN2
           IBUF(4,SIZ) = XN3
        END DO
C
Cow a cause de la version simple precision, on ne peux pas metre l'entier
Cow dans le buffer flottant car on n a que 2puiss 24 bits dispo ~ 16 Million
Cow de noeuds au max

         MSGTYP = MSGOFF2
         CALL MPI_SEND(IBUF,4*SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .     MPI_COMM_WORLD,ierror)

       ELSE

C proc 0
        SIZ0 = 0
        DO I=1,CRKNOD(ICRK)%CRKNUMNODS
           EMPL = CRKNOD(ICRK)%XFENODES(I)
c           NG = CRKNOD(ICRK)%XFECRKNODID(I)
C
           SIZ0 = SIZ0 + 1
c           S = SQRT(XNORM(1,I)**2 + XNORM(2,I)**2 + XNORM(3,I)**2)
           S = ZERO
           IF(S.NE.ZERO)THEN
             S = S3000 / S
c             XN1 = XNORM(1,I) * S
c             XN2 = XNORM(2,I) * S
c             XN3 = XNORM(3,I) * S
           ELSE
             XN1 = 0
             XN2 = 0
             XN3 = IXNN
           END IF 
c           RNGLOB(1,NG) = XN1
c           RNGLOB(2,NG) = XN2
c           RNGLOB(3,NG) = XN3
           RNGLOB(1,SIZ0) = XN1
           RNGLOB(2,SIZ0) = XN2
           RNGLOB(3,SIZ0) = XN3
        END DO

          DO I=2,NSPMD

            MSGTYP = MSGOFF2

            CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                    MPI_COMM_WORLD,STATUS,ierror)
	    CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)

            CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)

            NREC = SIZ / 4


            DO K = 1, NREC
c              NG = IBUF(1,K)
c              RNGLOB(1,NG) = IBUF(2,K)
c              RNGLOB(2,NG) = IBUF(3,K)
c              RNGLOB(3,NG) = IBUF(4,K)
              SIZ0 = SIZ0 + 1
              RNGLOB(1,SIZ0) = IBUF(2,K)
              RNGLOB(2,SIZ0) = IBUF(3,K)
              RNGLOB(3,SIZ0) = IBUF(4,K)
            ENDDO
          ENDDO

C          DO I=1,NCRKNODG
          DO I=1,SIZ0
           CALL WRITE_S_C(RNGLOB(1,I),1)
           CALL WRITE_S_C(RNGLOB(2,I),1)
           CALL WRITE_S_C(RNGLOB(3,I),1)
         END DO
        END IF

        DEALLOCATE(IBUF)
        DEALLOCATE(RNGLOB)
C
#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_GATHERITAB_CRK           priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        GENANI                        src/anim/genani.F             
Chd|-- calls ---------------
Chd|        WRITE_I_C                     src/sortie/sortie_c.c         
Chd|        CRACKXFEM_MOD                 share/modules/crackxfem_mod.F 
Chd|====================================================================
       SUBROUTINE SPMD_GATHERITAB_CRK(ICRK,NUM,IDMAXNOD,NODGLOBXFE)
C-----------------------------------------------
      USE CRACKXFEM_MOD        
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "task_c.inc"
#include      "spmd_c.inc"
#include      "param_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
       INTEGER ICRK,NUM,IDMAXNOD,NODGLOBXFE(*)
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,STEP

Cow Tableau utilise par proc 0
       INTEGER, DIMENSION(:,:),ALLOCATABLE :: IBUF
       INTEGER, DIMENSION(:),ALLOCATABLE :: XGLOB
C-----------------------------------------------
      DATA MSGOFF/7068/
C-----------------------------------------------
       ALLOCATE(IBUF(2,NCRKNODG))
       ALLOCATE(XGLOB(NUM))

       IF(ISPMD /= 0)THEN
         SIZ = 0
         STEP = 0
         DO I=1,CRKNOD(ICRK)%CRKNUMNODS
           SIZ = SIZ + 1
           STEP = CRKNOD(ICRK)%CRKNUMNODS*(ICRK-1)
           IBUF(1,SIZ) = NODGLOBXFE(I+STEP)
           IBUF(2,SIZ) = CRKNOD(ICRK)%XFECRKNODID(I)+IDMAXNOD
         END DO
C
         MSGTYP = MSGOFF
         CALL MPI_SEND(IBUF,2*SIZ,MPI_INTEGER,IT_SPMD(1),MSGTYP,
     .                 MPI_COMM_WORLD,ierror)
       ELSE
C proc 0 
       STEP = 0
        DO I=1,CRKNOD(ICRK)%CRKNUMNODS
          STEP = CRKNOD(ICRK)%CRKNUMNODS*(ICRK-1)
          NG = NODGLOBXFE(I+STEP)
          XGLOB(NG) = CRKNOD(ICRK)%XFECRKNODID(I)+IDMAXNOD
cc          CALL WRITE_I_C(XGLOB(NG),1)
        ENDDO
C all the rest procs
        DO I=2,NSPMD
Cow Reception du buffer entier des adresses NODGLOB
          MSGTYP = MSGOFF 
          CALL MPI_PROBE(IT_SPMD(I),MSGTYP,
     .                   MPI_COMM_WORLD,STATUS,ierror)
	  CALL MPI_GET_COUNT(STATUS,MPI_INTEGER,SIZ,ierror)
          CALL MPI_RECV(IBUF,SIZ,MPI_INTEGER,IT_SPMD(I),MSGTYP,
     .                  MPI_COMM_WORLD,STATUS,ierror)
C         
          NREC = SIZ/2
          DO K = 1, NREC
            NG = IBUF(1,K)
            XGLOB(NG) = IBUF(2,K)
cc            CALL WRITE_I_C(XGLOB(NG),1)
          ENDDO
        ENDDO ! DO I=2,NSPMD
cc          CALL WRITE_I_C(XGLOB,NUM)
C
        DO I=1,NCRKNODG
          K=I+NCRKNODG*(ICRK-1)
          CALL WRITE_I_C(XGLOB(K),1)
        ENDDO
C
       ENDIF
C
       DEALLOCATE(IBUF)
       DEALLOCATE(XGLOB)
#endif
       RETURN
       END
Chd|====================================================================
Chd|  SPMD_GATHER_WA                priv/spe/spmd_anim.F          
Chd|-- called by -----------
Chd|        DPARRWS                       src/anim/dparrws.F            
Chd|-- calls ---------------
Chd|====================================================================
       SUBROUTINE SPMD_GATHER_WA(MODE,SIZE_BUFFER_S,SIZE_BUFFER_R,SINDEX,RINDEX_PROC,
     1                           BUFFER_S,BUFFER_R,SHIFT_R,NB_ELEM_R)
C-----------------------------------------------    
C-----------------------------------------------
C   I m p l i c i t   T y p e s
C-----------------------------------------------
#include      "implicit_f.inc"
#include      "r4r8_p.inc"
#ifdef MPI
#include "mpif.h"
#endif
C-----------------------------------------------
C   C o m m o n   B l o c k s
C-----------------------------------------------
#include      "spmd_c.inc"
#include      "scr03_c.inc"
#include      "com01_c.inc"
#include      "com04_c.inc"
#include      "scr05_c.inc"
#include      "param_c.inc"
#include      "task_c.inc"
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
!       MODE = 0 --> collect the index array for each proc   
!       MODE = 1 --> collect all the buffer arraies
!       SIZE_BUFFER_S is the size of the local sended array
        INTEGER, INTENT(IN) :: MODE,SIZE_BUFFER_S
!       SIZE_BUFFER_R is the size of the global received array, proc 0 
        INTEGER, INTENT(INOUT) :: SIZE_BUFFER_R
!       SINDEX : index buffer array, local on each proc                      
        INTEGER, DIMENSION(NSECT+1,3), INTENT(IN) :: SINDEX
!       RINDEX_PROC : global index buffer array, only on proc 0
        INTEGER, DIMENSION(NSECT+1,3,NSPMD), INTENT(INOUT) :: RINDEX_PROC
!       BUFFER_S : sended buffer
        INTEGER, DIMENSION(SIZE_BUFFER_S), INTENT(IN) :: BUFFER_S
!       BUFFER_R : received buffer, size = SIZE_BUFFER_R on proc 0
        INTEGER, DIMENSION(*), INTENT(INOUT) :: BUFFER_R
        INTEGER, DIMENSION(NSPMD), INTENT(INOUT) :: SHIFT_R,NB_ELEM_R
C-----------------------------------------------
C   L O C A L   V A R I A B L E S
C-----------------------------------------------
#ifdef MPI
      INTEGER STATUS(MPI_STATUS_SIZE),IERROR,MSGOFF
      INTEGER SIZ,MSGTYP,I,K,NG,NREC,STEP

C-----------------------------------------------
      DATA MSGOFF/7069/
C-----------------------------------------------
        
        IF(MODE==0) THEN
        !       collect the local index arraies on the master processor
                CALL MPI_GATHER(SINDEX,3*(NSECT+1),MPI_INTEGER,
     .                   RINDEX_PROC,3*(NSECT+1),MPI_INTEGER,0,MPI_COMM_WORLD,ierror)  
        !       sum all the size of local sended arraies in order to get the size 
        !       of the global array on proc 0                  
                IF(ISPMD==0) THEN
                        NB_ELEM_R(1:NSPMD) = RINDEX_PROC(NSECT+1,1,1:NSPMD)
                        SIZE_BUFFER_R = 0
                        DO I=1,NSPMD
                                SIZE_BUFFER_R = SIZE_BUFFER_R + NB_ELEM_R(I)
                        ENDDO
        !       shift for the _gatherv comm
                        SHIFT_R(1) = 0
                        DO I=2,NSPMD
                                SHIFT_R(I) = SHIFT_R(I-1)+NB_ELEM_R(I-1)
                        ENDDO
                ELSE
                        SIZE_BUFFER_R = 0
                ENDIF
        ELSEIF(MODE==1) THEN

                CALL MPI_GATHERV(BUFFER_S,SIZE_BUFFER_S,MPI_INTEGER,
     .                           BUFFER_R,NB_ELEM_R,SHIFT_R,MPI_INTEGER,
     .                           0,MPI_COMM_WORLD,ierror)   
        ENDIF
#endif
       RETURN
       END

